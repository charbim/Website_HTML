<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinate Graph Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem;
            color: white;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
        }

        .function-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            margin-left: auto; /* push to the right edge */
        }

        .function-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 0.4rem 0.8rem;
            color: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            text-align: center;
        }

        .function-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .function-group {
            display: flex;
            gap: 0.3rem;
            align-items: center;
        }

        .function-group-label {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin-right: 0.3rem;
        }

        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .input-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            font-size: 1.2rem;
            font-weight: bold;
        }

        input[type="text"] {
            flex: 1;
            min-width: 300px;
            padding: 0.8rem 1.2rem;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            outline: none;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.3);
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        button {
            padding: 0.8rem 2rem;
            font-size: 1.1rem;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .examples {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .examples strong {
            color: white;
        }

        .graphs-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .graph-wrapper {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .graph-controls {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .control-btn {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .graph-title {
            text-align: center;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            font-weight: bold;
        }

        .zoom-info {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            margin-top: 0.5rem;
        }

        canvas {
            width: 100%;
            height: 500px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            cursor: crosshair;
        }

        #cartesianCanvas {
            cursor: grab;
        }

        #cartesianCanvas.dragging {
            cursor: grabbing;
        }

        .polar-canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        #polarCanvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .error-message {
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            color: white;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        @media (max-width: 1024px) {
            .graphs-container {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2rem;
            }

            .input-group {
                flex-direction: column;
            }

            input[type="text"] {
                width: 100%;
                min-width: auto;
            }
            
            #rangeSection .input-group {
                grid-template-columns: 1fr 1fr !important;
            }
        }
        
        @media (max-width: 600px) {
            #rangeSection .input-group {
                grid-template-columns: 1fr !important;
            }
        }

        .slider-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .slider-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
        }

        .slider-mode-toggle {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .mode-btn {
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.6);
            font-weight: bold;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .slider-range-inputs {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .slider-range-inputs input[type="number"] {
            width: 120px;
            padding: 0.6rem;
            font-size: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .slider-range-inputs label {
            font-size: 0.9rem;
            margin-right: 0.3rem;
        }

        .slider-container {
            margin-top: 1rem;
        }

        .slider-wrapper {
            position: relative;
            margin: 1rem 0;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .slider-value {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            margin-top: 0.5rem;
            color: white;
        }

        .slider-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 0.3rem;
        }
        /* Make slider min/max labels look editable and obvious */
        .slider-info span {
            background: rgba(255, 255, 255, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 6px;
            padding: 4px 8px;
            cursor: text !important;
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .slider-info span:hover {
            background: rgba(255, 255, 255, 0.28);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        /* Hide the variables shortcut group under the equation box */
        .function-menu .function-group:first-child {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“Š Coordinate Graph Visualizer</h1>
        
        <div class="input-section">
            <div class="input-group">
                <label for="equation">Equation:</label>
                <input type="text" id="equation" placeholder="Enter equation (e.g., sin(x), r*cos(theta), sqrt(x))" value="sin(x)">
                <button onclick="toggleRangeSection()" style="padding: 0.8rem 1.5rem; font-size: 1rem; margin-left: 0.5rem;">Adjust Range</button>
                <div class="function-menu">
                    <div class="function-group">
                        <span class="function-group-label">Vars:</span>
                        <button class="function-btn" onclick="insertSymbol('Î¸')">Î¸</button>
                        <button class="function-btn" onclick="insertSymbol('r')">r</button>
                        <button class="function-btn" onclick="insertSymbol('x')">x</button>
                        <button class="function-btn" onclick="insertSymbol('Ï€')">Ï€</button>
                    </div>
                    <div class="function-group">
                        <span class="function-group-label">Func:</span>
                        <button class="function-btn" onclick="insertSymbol('sin(')">sin</button>
                        <button class="function-btn" onclick="insertSymbol('cos(')">cos</button>
                        <button class="function-btn" onclick="insertSymbol('tan(')">tan</button>
                        <button class="function-btn" onclick="insertSymbol('sqrt(')">âˆš</button>
                        <button class="function-btn" onclick="insertSymbol('log(')">log</button>
                        <button class="function-btn" onclick="insertSymbol('exp(')">exp</button>
                        <button class="function-btn" onclick="insertSymbol('abs(')">abs</button>
                    </div>
                    <div class="function-group">
                        <span class="function-group-label">Ops:</span>
                        <button class="function-btn" onclick="insertSymbol('^')">xÂ²</button>
                        <button class="function-btn" onclick="insertSymbol('*')">Ã—</button>
                        <button class="function-btn" onclick="insertSymbol('/')">Ã·</button>
                        <button class="function-btn" onclick="insertSymbol('+')">+</button>
                        <button class="function-btn" onclick="insertSymbol('-')">-</button>
                        <button class="function-btn" onclick="insertSymbol('(')">(</button>
                        <button class="function-btn" onclick="insertSymbol(')')">)</button>
                    </div>
                </div>
            </div>
            <div class="examples">
                <strong>Examples:</strong> sin(x), cos(x), x^2, sqrt(x), square(x), r*cos(theta), theta^2, sin(theta), exp(x), log(x), abs(x)
            </div>
            <div class="error-message" id="errorMessage"></div>
        </div>

        <div class="input-section" id="rangeSection" style="display: none;">
            <div style="margin-bottom: 1rem;">
                <h3 style="font-size: 1.3rem; margin-bottom: 0.5rem;">Adjust Range</h3>
                <p style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.8); margin-bottom: 1rem;">
                    Manually set the bounds for both graphs. Leave empty to use auto-detected range.
                </p>
            </div>
            <div class="input-group" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem;">
                <div>
                    <label for="xMin" style="font-size: 0.9rem; display: block; margin-bottom: 0.3rem;">Î¸ Min:</label>
                    <input type="number" id="xMin" placeholder="Auto" step="any" style="width: 100%; padding: 0.6rem; font-size: 1rem;">
                </div>
                <div>
                    <label for="xMax" style="font-size: 0.9rem; display: block; margin-bottom: 0.3rem;">Î¸ Max:</label>
                    <input type="number" id="xMax" placeholder="Auto" step="any" style="width: 100%; padding: 0.6rem; font-size: 1rem;">
                </div>
                <div>
                    <label for="yMin" style="font-size: 0.9rem; display: block; margin-bottom: 0.3rem;">r Min:</label>
                    <input type="number" id="yMin" placeholder="Auto" step="any" style="width: 100%; padding: 0.6rem; font-size: 1rem;">
                </div>
                <div>
                    <label for="yMax" style="font-size: 0.9rem; display: block; margin-bottom: 0.3rem;">r Max:</label>
                    <input type="number" id="yMax" placeholder="Auto" step="any" style="width: 100%; padding: 0.6rem; font-size: 1rem;">
                </div>
            </div>
            <div style="margin-top: 1rem; display: flex; gap: 0.5rem;">
                <button onclick="resetRangeToAuto()" style="padding: 0.6rem 1.5rem; font-size: 0.95rem;">Reset to Auto</button>
                <button onclick="toggleRangeSection()" style="padding: 0.6rem 1.5rem; font-size: 0.95rem;">Hide Range Controls</button>
            </div>
        </div>

        <div class="slider-section" id="sliderSection">
            <div style="margin-bottom: 1rem;">
                <h3 style="font-size: 1.3rem; margin-bottom: 0.5rem;">Theta Slider</h3>
                <p style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.8); margin-bottom: 1rem;">
                    Move the slider to see the point on both graphs. Choose between pre-drawn mode (dot travels) or drawing mode (graph draws as you move).
                </p>
            </div>
            <div class="slider-controls">
                <div class="slider-mode-toggle">
                    <span style="font-size: 0.95rem; margin-right: 0.5rem;">Mode:</span>
                    <button class="mode-btn active" id="modePreDrawn" onclick="setSliderMode('preDrawn')">Pre-drawn</button>
                    <button class="mode-btn" id="modeDrawing" onclick="setSliderMode('drawing')">Drawing</button>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-wrapper">
                    <input type="range" id="thetaSlider" min="0" max="100" value="0" step="0.01">
                    <div class="slider-value" id="sliderValue">Î¸ = 0.00</div>
                    <div class="slider-info" style="display: flex; justify-content: space-between; gap: 1rem; margin-top: 0.25rem;">
                        <span id="sliderMinLabel" title="Click to edit">Min: 0.00</span>
                        <span id="sliderMaxLabel" title="Click to edit">Max: 0.00</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="graphs-container">
            <div class="graph-wrapper">
                <div class="graph-title">Cartesian Coordinates</div>
                <div class="graph-controls">
                    <button class="control-btn" onclick="resetZoomCartesian()">Reset View</button>
                </div>
                <canvas id="cartesianCanvas"></canvas>
                <div class="zoom-info" id="cartesianZoomInfo">Click and drag to pan | Scroll to zoom</div>
            </div>
            <div class="graph-wrapper">
                <div class="graph-title">Polar Coordinates</div>
                <div class="graph-controls">
                    <button class="control-btn" onclick="resetZoomPolar()">Reset View</button>
                </div>
                <div class="polar-canvas-container">
                    <canvas id="polarCanvas"></canvas>
                </div>
                <div class="zoom-info" id="polarZoomInfo">Scroll to zoom</div>
            </div>
        </div>
    </div>

    <script>
        const cartesianCanvas = document.getElementById('cartesianCanvas');
        const polarCanvas = document.getElementById('polarCanvas');
        const equationInput = document.getElementById('equation');
        const errorMessage = document.getElementById('errorMessage');
        const cartesianZoomInfo = document.getElementById('cartesianZoomInfo');
        const polarZoomInfo = document.getElementById('polarZoomInfo');

        // Pan and zoom state
        let cartesianZoom = 1.0;
        let cartesianCenterX = 0;
        let cartesianCenterY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let polarZoom = 1.0;
        
        // Manual range bounds (null means auto)
        let manualXMin = null;
        let manualXMax = null;
        let manualYMin = null;
        let manualYMax = null;

        // Slider state
        let sliderMode = 'preDrawn'; // 'preDrawn' or 'drawing'
        let currentTheta = 0;
        let sliderMin = null; // null means use manualXMin or auto
        let sliderMax = null; // null means use manualXMax or auto
        let sliderTheta = 0; // Current slider theta value

        // Add custom functions to math.js
        math.import({
            square: function(x) {
                return x * x;
            }
        }, { override: true });

        // Set canvas dimensions
        function setupCanvas(canvas) {
            if (canvas.id === 'polarCanvas') {
                // Make polar canvas square based on container width
                const containerRect = canvas.parentElement.getBoundingClientRect();
                const size = containerRect.width;
                canvas.width = size;
                canvas.height = size;
            } else {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = 500;
            }
        }

        setupCanvas(cartesianCanvas);
        setupCanvas(polarCanvas);

        // Handle window resize
        window.addEventListener('resize', () => {
            setupCanvas(cartesianCanvas);
            setupCanvas(polarCanvas);
            if (equationInput.value) {
                plotGraph();
            }
        });

        // Real-time updates with debouncing
        let updateTimeout;
        equationInput.addEventListener('input', () => {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                // Auto-detect periodicity and set range
                const equation = equationInput.value.trim();
                if (equation) {
                    autoSetRange(equation);
                }
                updateSliderBounds();
                plotGraph();
            }, 300); // 300ms delay
        });

        // Mouse wheel zoom for cartesian
        cartesianCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = cartesianCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const padding = 60;
            const plotWidth = cartesianCanvas.width - 2 * padding;
            const plotHeight = cartesianCanvas.height - 2 * padding;
            
            const baseRange = 10 / cartesianZoom;
            const xMin = cartesianCenterX - baseRange;
            const xMax = cartesianCenterX + baseRange;
            const yMin = cartesianCenterY - baseRange;
            const yMax = cartesianCenterY + baseRange;
            
            // Convert mouse position to graph coordinates (point to keep fixed)
            const graphX = xMin + ((mouseX - padding) / plotWidth) * (xMax - xMin);
            const graphY = yMax - ((mouseY - padding) / plotHeight) * (yMax - yMin);
            
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            const oldZoom = cartesianZoom;
            cartesianZoom *= factor;
            
            // Adjust center so the point under mouse stays fixed
            const newRange = 10 / cartesianZoom;
            const oldRange = 10 / oldZoom;
            cartesianCenterX = graphX - ((mouseX - padding) / plotWidth - 0.5) * 2 * newRange;
            cartesianCenterY = graphY + ((mouseY - padding) / plotHeight - 0.5) * 2 * newRange;
            
            plotGraph();
        });

        // Click and drag panning for cartesian
        cartesianCanvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            cartesianCanvas.classList.add('dragging');
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = cartesianCanvas.getBoundingClientRect();
                const padding = 60;
                const plotWidth = cartesianCanvas.width - 2 * padding;
                const plotHeight = cartesianCanvas.height - 2 * padding;
                
                const baseRange = 10 / cartesianZoom;
                const xRange = 2 * baseRange;
                const yRange = 2 * baseRange;
                
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                // Convert pixel movement to graph coordinate movement
                const dx = -(deltaX / plotWidth) * xRange;
                const dy = (deltaY / plotHeight) * yRange;
                
                cartesianCenterX += dx;
                cartesianCenterY -= dy; // drag down -> content down
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                plotGraph();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                cartesianCanvas.classList.remove('dragging');
            }
        });

        function resetZoomCartesian() {
            cartesianZoom = 1.0;
            cartesianCenterX = 0;
            cartesianCenterY = 0;
            polarZoom = 1.0; // Reset polar zoom to maintain sync
            plotGraph();
            updateRangeInputsFromView();
        }

        // Mouse wheel zoom for polar
        polarCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            polarZoom *= factor;
            plotGraph();
        });

        function resetZoomPolar() {
            polarZoom = 1.0;
            plotGraph();
        }

        function insertSymbol(symbol) {
            const input = equationInput;
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const text = input.value;
            const before = text.substring(0, start);
            const after = text.substring(end);
            
            input.value = before + symbol + after;
            input.selectionStart = input.selectionEnd = start + symbol.length;
            input.focus();
            
            // Trigger input event to update graph
            input.dispatchEvent(new Event('input'));
        }

        // Detect periodicity and calculate appropriate range
        function detectPeriodicity(equation) {
            const processed = preprocessEquation(equation);
            const hasSin = /\bsin\b/.test(processed);
            const hasCos = /\bcos\b/.test(processed);
            const hasTan = /\btan\b/.test(processed);
            
            if (hasSin || hasCos) {
                // sin and cos have period 2Ï€
                return { period: 2 * Math.PI, periods: 1 };
            } else if (hasTan) {
                // tan has period Ï€
                return { period: Math.PI, periods: 1 };
            }
            
            return null; // No periodicity detected
        }

        // Compute current view bounds (ignores manual fields; view is driven by zoom/center)
        function getViewBounds() {
            const baseRange = 10 / cartesianZoom;
            return {
                xMin: cartesianCenterX - baseRange,
                xMax: cartesianCenterX + baseRange,
                yMin: cartesianCenterY - baseRange,
                yMax: cartesianCenterY + baseRange
            };
        }

        // Apply view from explicit bounds; keeps graph as the source of truth
        function setViewFromRange(xMin, xMax, yMin, yMax) {
            if ([xMin, xMax, yMin, yMax].some(v => typeof v !== 'number' || !isFinite(v))) {
                return;
            }
            const centerX = (xMin + xMax) / 2;
            const centerY = (yMin + yMax) / 2;
            const halfX = Math.abs(xMax - xMin) / 2;
            const halfY = Math.abs(yMax - yMin) / 2;
            const desiredBaseRange = Math.max(halfX, halfY, 0.0001);
            cartesianCenterX = centerX;
            cartesianCenterY = centerY;
            cartesianZoom = 10 / desiredBaseRange;
            // Clear any manual overrides; view is authoritative
            manualXMin = null;
            manualXMax = null;
            manualYMin = null;
            manualYMax = null;
            plotGraph();
        }

        // Keep range inputs in sync with current view unless the user is actively editing
        let isEditingRangeInput = false;
        function updateRangeInputsFromView() {
            const xMinInput = document.getElementById('xMin');
            const xMaxInput = document.getElementById('xMax');
            const yMinInput = document.getElementById('yMin');
            const yMaxInput = document.getElementById('yMax');
            if (!xMinInput || !xMaxInput || !yMinInput || !yMaxInput) return;
            if (isEditingRangeInput) return;
            const { xMin, xMax, yMin, yMax } = getViewBounds();
            xMinInput.value = xMin.toFixed(3);
            xMaxInput.value = xMax.toFixed(3);
            yMinInput.value = yMin.toFixed(3);
            yMaxInput.value = yMax.toFixed(3);
        }

        // Auto-set initial view range based on periodicity (non-intrusive; does not show UI)
        function autoSetRange(equation) {
            if (!equation || !equation.trim()) return;
            try {
                const processed = preprocessEquation(equation);
                const periodicity = detectPeriodicity(processed);
                if (!periodicity) return;
                const { period } = periodicity;
                const thetaMin = 0;
                const thetaMax = period;

                // Sample r over theta range to estimate y bounds
                const sampleStep = 0.02;
                let minR = Infinity;
                let maxR = -Infinity;
                let evalExpr = processed;
                if (processed.includes('=')) {
                    const parts = processed.split('=');
                    if (parts.length === 2) {
                        evalExpr = parts[1].trim();
                    }
                }
                for (let theta = thetaMin; theta <= thetaMax; theta += sampleStep) {
                    try {
                        const expr = evalExpr.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        let r = math.evaluate(expr);
                        if (typeof r === 'object' && r.re !== undefined) r = r.re;
                        if (!isNaN(r) && isFinite(r)) {
                            minR = Math.min(minR, r);
                            maxR = Math.max(maxR, r);
                        }
                    } catch (e) {}
                }
                if (!isFinite(minR) || !isFinite(maxR)) {
                    minR = -10;
                    maxR = 10;
                }
                const padding = Math.max((maxR - minR) * 0.1, 0.1);
                setViewFromRange(thetaMin, thetaMax, minR - padding, maxR + padding);
                updateRangeInputsFromView();
            } catch (e) {
                // Silent fail
            }
        }

        function toggleRangeSection() {
            const section = document.getElementById('rangeSection');
            if (section.style.display === 'none') {
                section.style.display = 'block';
                // Pre-fill with current view values when opening
                updateRangeInputsFromView();
            } else {
                section.style.display = 'none';
            }
        }

        function resetRangeToAuto() {
            manualXMin = null;
            manualXMax = null;
            manualYMin = null;
            manualYMax = null;
            
            updateRangeInputsFromView();
            
            plotGraph();
        }

        // Add event listeners for range inputs (setup after DOM is ready)
        function setupRangeInputListeners() {
            const rangeInputs = ['xMin', 'xMax', 'yMin', 'yMax'];
            rangeInputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('focus', () => { isEditingRangeInput = true; });
                    input.addEventListener('blur', () => { isEditingRangeInput = false; });
                    let updateTimeout;
                    input.addEventListener('input', () => {
                        clearTimeout(updateTimeout);
                        updateTimeout = setTimeout(() => {
                            // Read all inputs and apply view
                            const bounds = getViewBounds();
                            const xMinInput = parseFloat(document.getElementById('xMin').value);
                            const xMaxInput = parseFloat(document.getElementById('xMax').value);
                            const yMinInput = parseFloat(document.getElementById('yMin').value);
                            const yMaxInput = parseFloat(document.getElementById('yMax').value);
                            const xMin = isNaN(xMinInput) ? bounds.xMin : xMinInput;
                            const xMax = isNaN(xMaxInput) ? bounds.xMax : xMaxInput;
                            const yMin = isNaN(yMinInput) ? bounds.yMin : yMinInput;
                            const yMax = isNaN(yMaxInput) ? bounds.yMax : yMaxInput;
                            setViewFromRange(xMin, xMax, yMin, yMax);
                            updateRangeInputsFromView();
                        }, 300);
                    });
                }
            });
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('show');
            setTimeout(() => {
                errorMessage.classList.remove('show');
            }, 5000);
        }

        // Insert implicit multiplication so inputs like "sin(3x)", "2pi", "(x+1)(x-1)" work without explicit '*'
        function addImplicitMultiplication(expr) {
            if (!expr || typeof expr !== 'string') return expr;
            
            // 1) Number followed by (variable|constant|function|()
            //    e.g., 3theta -> 3*theta, 2pi -> 2*pi, 4sin(theta) -> 4*sin(theta), 5(x+1) -> 5*(x+1)
            //    Avoid touching numbers that are part of identifiers like "log10(".
            expr = expr.replace(/(\d+(?:\.\d+)?)(?=\s*(?:theta|r|pi|sin|cos|tan|sqrt|log|exp|abs|square|\())/g, function(match, num, offset, str) {
                const prev = offset > 0 ? str[offset - 1] : '';
                if (prev && /[A-Za-z0-9_.]/.test(prev)) {
                    return match; // skip numbers that are part of identifiers (e.g., log10)
                }
                return num + '*';
            });
            
            // 2) (variable|constant|')') followed by (variable|constant|function|'(' | number)
            //    e.g., theta(x+1) -> theta*(x+1), pi theta -> pi*theta, )( -> )*(, r2 -> r*2
            expr = expr.replace(/(\btheta\b|\br\b|\bpi\b|\))(?=\s*(?:\btheta\b|\br\b|\bpi\b|sin|cos|tan|sqrt|log|exp|abs|square|\(|\d+(?:\.\d+)?))/g, '$1*');
            
            return expr;
        }

        // Preprocess equation to handle various function names and variables
        function preprocessEquation(equation) {
            // Replace common function names
            let processed = equation
                .replace(/\bsqrt\b/g, 'sqrt')
                .replace(/\bsquare\b/g, 'square')
                .replace(/Î¸/g, 'theta')
                .replace(/\btheta\b/g, 'theta')
                .replace(/\bÏ€\b/g, 'pi')
                .replace(/\bPI\b/g, 'pi')
                // Treat x as theta and y as r (canonicalize variables)
                .replace(/\bx\b/g, 'theta')
                .replace(/\by\b/g, 'r');
            // Add implicit multiplication so inputs like "sin(3x)" evaluate correctly
            processed = addImplicitMultiplication(processed);
            return processed;
        }

        // Detect which variables are used in the equation
        function detectVariables(equation) {
            const hasR = /\br\b/.test(equation);
            const hasTheta = /\btheta\b/.test(equation);
            // Canonical variables only
            return { hasX: false, hasY: false, hasR, hasTheta };
        }

        function plotGraph() {
            const equation = equationInput.value.trim();
            if (!equation) {
                return;
            }

            try {
                const processed = preprocessEquation(equation);
                const vars = detectVariables(processed);

                // If an equality is present, require the left side to include r (or y before canonicalization)
                let evalExpr = processed;
                if (processed.includes('=')) {
                    const parts = processed.split('=');
                    const lhs = parts[0].trim();
                    const rhs = parts.slice(1).join('=').trim();
                    if (!/\br\b/.test(lhs)) {
                        throw new Error("When using '=', put r on the left, e.g., r = f(theta)");
                    }
                    evalExpr = rhs;
                }

                // Test evaluate only the RHS expression
                const testExpr = evalExpr
                    .replace(/\br\b/g, '(1)')
                    .replace(/\btheta\b/g, '(1)');
                math.evaluate(testExpr);

                plotCartesian(processed, vars);
                plotPolar(processed, vars);
                errorMessage.classList.remove('show');
                // Keep range inputs synced with view
                updateRangeInputsFromView();
            } catch (error) {
                showError('Invalid equation: ' + error.message);
            }
        }

        // Quick visibility check: does the cartesian function intersect current viewport?
        function cartesianFunctionIntersectsViewport(equation, vars, xMin, xMax, yMin, yMax) {
            // Decide which variable drives the horizontal axis (Î¸ by default, fallback to x)
            let iterateVar = 'theta';
            if (vars.hasX && !vars.hasTheta && !vars.hasR) {
                iterateVar = 'x';
            }

            const samples = 256; // coarse sampling for a fast visibility test
            const step = (xMax - xMin) / samples;

            for (let i = 0; i <= samples; i++) {
                const val = xMin + i * step;
                try {
                    let expr = equation;
                    let y;

                    if (iterateVar === 'theta') {
                        const theta = val;
                        if (equation.includes('=')) {
                            const parts = equation.split('=');
                            if (parts.length === 2) {
                                const rightSide = parts[1].trim();
                                expr = rightSide.replace(/\btheta\b/g, `(${theta})`);
                            }
                        } else {
                            // Treat result as r, allow x as alias for theta
                            expr = equation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        }
                        y = math.evaluate(expr);
                    } else {
                        const x = val;
                        expr = equation.replace(/\bx\b/g, `(${x})`);
                        y = math.evaluate(expr);
                    }

                    if (typeof y === 'object' && y.re !== undefined) {
                        y = y.re;
                    }

                    if (!isNaN(y) && isFinite(y) && y >= yMin && y <= yMax) {
                        return true; // intersects the visible y-range
                    }
                } catch (e) {
                    // ignore individual evaluation errors during visibility sampling
                }
            }

            return false;
        }

        function plotCartesian(equation, vars) {
            const ctx = cartesianCanvas.getContext('2d');
            const width = cartesianCanvas.width;
            const height = cartesianCanvas.height;
            const padding = 60;
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            // Set up coordinate system from view (zoom + center drive the range)
            const baseRangeView = 10 / cartesianZoom;
            const xMin = cartesianCenterX - baseRangeView;
            const xMax = cartesianCenterX + baseRangeView;
            const yMin = cartesianCenterY - baseRangeView;
            const yMax = cartesianCenterY + baseRangeView;
            
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;
            // Provide a consistent baseRange for thresholds/label logic
            const baseRange = Math.max(xRange, yRange) / 2;

            // Update zoom info
            cartesianZoomInfo.textContent = `Zoom: ${cartesianZoom.toFixed(2)}x | Click and drag to pan`;

            // Draw grid (world-aligned with nice steps)
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            function niceStepForRange(range) {
                const targetLines = 10;
                const rough = range / targetLines;
                if (rough <= 0) return 1;
                
                const pow10 = Math.pow(10, Math.floor(Math.log10(Math.abs(rough))));
                const n = Math.abs(rough) / pow10;
                let nice;
                
                // Gradual scaling: prefer larger steps, scale down slowly
                // 10, 5, 2, 1, 0.5, 0.2, 0.1, etc.
                if (n > 7) nice = 10;
                else if (n > 3) nice = 5;
                else if (n > 1.5) nice = 2;
                else if (n > 0.7) nice = 1;
                else if (n > 0.35) nice = 0.5;
                else if (n > 0.15) nice = 0.2;
                else if (n > 0.07) nice = 0.1;
                else if (n > 0.035) nice = 0.05;
                else if (n > 0.015) nice = 0.02;
                else nice = 0.01;
                
                return nice * pow10;
            }

            const gridXStep = niceStepForRange(xRange);
            const gridYStep = niceStepForRange(yRange);
            
            // Check if we'll be showing decimals
            const defaultRange = 10;
            const effectiveZoom = defaultRange / baseRange;
            const willShowXDecimals = (effectiveZoom >= 2.0 && gridXStep < 1) || 
                                      (effectiveZoom >= 3.0 && gridXStep >= 1 && gridXStep < 10);
            const willShowYDecimals = (effectiveZoom >= 2.0 && gridYStep < 1) || 
                                      (effectiveZoom >= 3.0 && gridYStep >= 1 && gridYStep < 10);
            
            // Draw X grid lines
            const xStartGrid = Math.ceil(xMin / gridXStep) * gridXStep;
            for (let gx = xStartGrid; gx <= xMax + 1e-9; gx += gridXStep) {
                const px = padding + ((gx - xMin) / xRange) * plotWidth;
                const isWholeNumber = willShowXDecimals && (Math.abs(gx % 1) < 0.0001 || 
                                    Math.abs(gx - Math.round(gx)) < 0.0001);
                
                // Make whole number lines darker when decimals are present
                if (isWholeNumber) {
                    ctx.strokeStyle = '#c0c0c0';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                }
                
                ctx.beginPath();
                ctx.moveTo(px, padding);
                ctx.lineTo(px, height - padding);
                ctx.stroke();
            }
            
            // Draw Y grid lines
            const yStartGrid = Math.ceil(yMin / gridYStep) * gridYStep;
            for (let gy = yStartGrid; gy <= yMax + 1e-9; gy += gridYStep) {
                const py = padding + ((yMax - gy) / yRange) * plotHeight;
                const isWholeNumber = willShowYDecimals && (Math.abs(gy % 1) < 0.0001 || 
                                    Math.abs(gy - Math.round(gy)) < 0.0001);
                
                // Make whole number lines darker when decimals are present
                if (isWholeNumber) {
                    ctx.strokeStyle = '#c0c0c0';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                }
                
                ctx.beginPath();
                ctx.moveTo(padding, py);
                ctx.lineTo(width - padding, py);
                ctx.stroke();
            }
            
            // Reset stroke style
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            // y=0 mapped to screen (clamped to nearest edge if out of view)
            let xAxisY = padding + ((yMax - 0) / yRange) * plotHeight;
            xAxisY = Math.max(padding, Math.min(height - padding, xAxisY));
            // x=0 mapped to screen (clamped to nearest edge if out of view)
            let yAxisX = padding + ((0 - xMin) / xRange) * plotWidth;
            yAxisX = Math.max(padding, Math.min(width - padding, yAxisX));

            // X-axis
            ctx.beginPath();
            ctx.moveTo(padding, xAxisY);
            ctx.lineTo(width - padding, xAxisY);
            ctx.stroke();

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(yAxisX, padding);
            ctx.lineTo(yAxisX, height - padding);
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            const xLabelStep = gridXStep;
            const xLabelStart = Math.ceil(xMin / xLabelStep) * xLabelStep;
            // Cap decimals at 1-2 max for cleaner look
            let xDecimals = 0;
            if (willShowXDecimals) {
                if (xLabelStep < 1) {
                    if (xLabelStep >= 0.1) {
                        xDecimals = 1;
                    } else if (xLabelStep >= 0.01) {
                        xDecimals = 2;
                    } else {
                        // For very small steps, cap at 2 decimals
                        xDecimals = 2;
                    }
                } else if (xLabelStep >= 1 && xLabelStep < 10) {
                    xDecimals = 1;
                }
            }
            for (let xv = xLabelStart; xv <= xMax + 1e-9; xv += xLabelStep) {
                if (Math.abs(xv) > xLabelStep * 0.05) {
                    const x = padding + ((xv - xMin) / xRange) * plotWidth;
                    ctx.fillText(xv.toFixed(xDecimals), x, xAxisY + 20);
                }
            }
            ctx.textAlign = 'right';
            const yLabelStep = gridYStep;
            const yLabelStart = Math.ceil(yMin / yLabelStep) * yLabelStep;
            // Cap decimals at 1-2 max for cleaner look
            let yDecimals = 0;
            if (willShowYDecimals) {
                if (yLabelStep < 1) {
                    if (yLabelStep >= 0.1) {
                        yDecimals = 1;
                    } else if (yLabelStep >= 0.01) {
                        yDecimals = 2;
                    } else {
                        // For very small steps, cap at 2 decimals
                        yDecimals = 2;
                    }
                } else if (yLabelStep >= 1 && yLabelStep < 10) {
                    yDecimals = 1;
                }
            }
            for (let yv = yLabelStart; yv <= yMax + 1e-9; yv += yLabelStep) {
                if (Math.abs(yv) > yLabelStep * 0.05) {
                    const y = padding + ((yMax - yv) / yRange) * plotHeight;
                    ctx.fillText(yv.toFixed(yDecimals), yAxisX - 10, y + 4);
                }
            }

            // Always use Î¸ for x-axis and r for y-axis
            const xLabel = 'Î¸';
            const yLabel = 'r';

            // Draw axis labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(xLabel, width - padding - 20, xAxisY + 35);
            ctx.textAlign = 'right';
            ctx.fillText(yLabel, yAxisX - 25, padding + 15);

            // Plot the function
            // If the function does not intersect the current viewport, skip drawing it
            if (!cartesianFunctionIntersectsViewport(equation, vars, xMin, xMax, yMin, yMax)) {
                return;
            }

            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();

            let firstPoint = true;
            const step = (xMax - xMin) / (plotWidth * 2); // Adaptive step size
            let lastY = null;

            // Always iterate over theta for cartesian (since we're plotting r vs Î¸)
            // But if only x is present, use x
            let iterateVar = 'theta';
            if (vars.hasX && !vars.hasTheta && !vars.hasR) {
                iterateVar = 'x';
            }

            const range = (xMax - xMin);
            const start = xMin;
            // In drawing mode, only draw up to sliderTheta; in pre-drawn mode, draw full range
            let end = xMax;
            if (sliderMode === 'drawing') {
                end = Math.min(xMax, Math.max(xMin, sliderTheta));
            }

            for (let val = start; val <= end; val += step) {
                try {
                    let expr = equation;
                    let y;
                    
                    // Always plot as r = f(Î¸) in cartesian (r on y-axis, Î¸ on x-axis)
                    if (iterateVar === 'theta') {
                        const theta = val;
                        // Handle equations like r = f(theta)
                        if (equation.includes('=')) {
                            const parts = equation.split('=');
                            if (parts.length === 2) {
                                const rightSide = parts[1].trim();
                                expr = rightSide.replace(/\btheta\b/g, `(${theta})`);
                            }
                        } else {
                            // Replace theta, treat result as r
                            // Also handle x as theta for backward compatibility
                            expr = equation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        }
                        y = math.evaluate(expr);
                    } else {
                        // Fallback to x if only x is present (treat as r = f(x) where x is theta)
                        const x = val;
                        expr = equation.replace(/\bx\b/g, `(${x})`);
                        y = math.evaluate(expr);
                    }

                    // Handle complex numbers
                    if (typeof y === 'object' && y.re !== undefined) {
                        y = y.re;
                    }

                    // Skip if y is out of range or invalid
                    if (isNaN(y) || !isFinite(y) || y < yMin - baseRange || y > yMax + baseRange) {
                        firstPoint = true;
                        lastY = null;
                        continue;
                    }

                    const plotX = padding + ((val - xMin) / xRange) * plotWidth;
                    const plotY = padding + ((yMax - y) / yRange) * plotHeight;

                    if (firstPoint) {
                        ctx.moveTo(plotX, plotY);
                        firstPoint = false;
                    } else {
                        // Check for discontinuities
                        if (lastY !== null && Math.abs(y - lastY) > baseRange * 2) {
                            ctx.moveTo(plotX, plotY);
                        } else {
                            ctx.lineTo(plotX, plotY);
                        }
                    }
                    lastY = y;
                } catch (error) {
                    firstPoint = true;
                    lastY = null;
                }
            }

            ctx.stroke();

            // Draw point at slider position
            if (sliderTheta >= xMin && sliderTheta <= xMax) {
                try {
                    let expr = equation;
                    let y;
                    
                    if (iterateVar === 'theta') {
                        const theta = sliderTheta;
                        if (equation.includes('=')) {
                            const parts = equation.split('=');
                            if (parts.length === 2) {
                                const rightSide = parts[1].trim();
                                expr = rightSide.replace(/\btheta\b/g, `(${theta})`);
                            }
                        } else {
                            expr = equation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        }
                        y = math.evaluate(expr);
                    } else {
                        const x = sliderTheta;
                        expr = equation.replace(/\bx\b/g, `(${x})`);
                        y = math.evaluate(expr);
                    }

                    if (typeof y === 'object' && y.re !== undefined) {
                        y = y.re;
                    }

                    if (!isNaN(y) && isFinite(y) && y >= yMin - baseRange && y <= yMax + baseRange) {
                        const plotX = padding + ((sliderTheta - xMin) / xRange) * plotWidth;
                        const plotY = padding + ((yMax - y) / yRange) * plotHeight;

                        // Draw a subtler point
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.arc(plotX, plotY, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw a light border for visibility
                        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                } catch (error) {
                    // Ignore errors when drawing point
                }
            }
        }

        function plotPolar(equation, vars) {
            const ctx = polarCanvas.getContext('2d');
            const width = polarCanvas.width;
            const height = polarCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const polarPadding = 10;
            const baseRadius = Math.min(width, height) / 2 - polarPadding;

            // Auto-sync polar zoom to match cartesian r-range
            const cartesianBaseRange = 10 / cartesianZoom;
            const cartesianYMin = cartesianCenterY - cartesianBaseRange;
            const cartesianYMax = cartesianCenterY + cartesianBaseRange;
            
            // Use the cartesian y-axis range directly for polar maxR
            // Polar shows r from 0 to maxR, so use the maximum r value from cartesian
            // If cartesian shows negative r values, we still show from 0 to max absolute
            let cartesianRMax = Math.max(Math.abs(cartesianYMin), Math.abs(cartesianYMax));
            
            // Sample to find max r from the function to ensure we show the full function
            const sampleStep = 0.01;
            const sampleThetaMax = 4 * Math.PI;
            let functionMaxR = cartesianRMax;
            
            for (let theta = 0; theta <= sampleThetaMax; theta += sampleStep * 10) {
                try {
                    let expr = equation;
                    if (vars.hasR && vars.hasTheta) {
                        if (equation.includes('=')) {
                            const parts = equation.split('=');
                            if (parts.length === 2) {
                                const rightSide = parts[1].trim();
                                expr = rightSide.replace(/\btheta\b/g, `(${theta})`);
                            }
                        } else {
                            expr = equation.replace(/\btheta\b/g, `(${theta})`);
                        }
                    } else if (vars.hasX && !vars.hasTheta) {
                        expr = equation.replace(/\bx\b/g, `(${theta})`);
                    } else if (vars.hasTheta) {
                        expr = equation.replace(/\btheta\b/g, `(${theta})`);
                    } else {
                        expr = equation.replace(/\bx\b/g, `(${theta})`);
                    }
                    
                    let r = math.evaluate(expr);
                    if (typeof r === 'object' && r.re !== undefined) {
                        r = r.re;
                    }
                    if (!isNaN(r) && isFinite(r)) {
                        functionMaxR = Math.max(functionMaxR, Math.abs(r) * 1.1);
                    }
                } catch (e) {}
            }
            
            // Use cartesian range as the primary maxR, but ensure we show the function if it extends beyond
            // The polar graph should show circles matching the cartesian y-axis range
            let maxR = Math.max(cartesianRMax, functionMaxR);
            
            // Apply manual polar zoom
            maxR = maxR / polarZoom;
            const radius = baseRadius;

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            // Draw concentric circles with adaptive increments
            // Scale gradually: start with whole numbers, then 0.5, then smaller increments
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Choose a circle step that adapts gradually to zoom level
            // Scale more slowly: 10, 5, 2, 1, 0.5, 0.2, 0.1, etc.
            const maxCircles = 12; // Reduced from 16 for cleaner look
            function chooseNiceStep(range, maxTicks) {
                const rough = range / maxTicks;
                if (rough <= 0) return 1;
                
                const pow10 = Math.pow(10, Math.floor(Math.log10(Math.abs(rough))));
                const n = Math.abs(rough) / pow10;
                let nice;
                
                // Gradual scaling: prefer larger steps, only go smaller when really needed
                if (n > 7) nice = 10;
                else if (n > 3) nice = 5;
                else if (n > 1.5) nice = 2;
                else if (n > 0.7) nice = 1;
                else if (n > 0.35) nice = 0.5;
                else if (n > 0.15) nice = 0.2;
                else if (n > 0.07) nice = 0.1;
                else if (n > 0.035) nice = 0.05;
                else if (n > 0.015) nice = 0.02;
                else nice = 0.01;
                
                return nice * pow10;
            }
            
            // Always choose an appropriate step based on maxR
            let circleStep = chooseNiceStep(maxR, maxCircles);
            
            // Ensure we have a reasonable number of circles
            let numCircles = Math.floor(maxR / circleStep);
            if (numCircles > maxCircles) {
                // Too many circles, increase step size
                circleStep = chooseNiceStep(maxR, maxCircles);
                numCircles = Math.floor(maxR / circleStep);
            } else if (numCircles < 4 && maxR > circleStep * 4) {
                // Too few circles, decrease step size slightly
                const smallerStep = circleStep / 2;
                const newNumCircles = Math.floor(maxR / smallerStep);
                if (newNumCircles <= maxCircles && newNumCircles >= 4) {
                    circleStep = smallerStep;
                    numCircles = newNumCircles;
                }
            }

            // Determine if we'll be showing decimals (needed for whole number highlighting)
            const totalZoom = cartesianZoom * polarZoom;
            let willShowDecimals = false;
            if (totalZoom >= 2.0) {
                if (circleStep < 1 || (circleStep === 0.5 && totalZoom >= 2.5) || 
                    (circleStep >= 1 && circleStep < 10 && totalZoom >= 3.0)) {
                    willShowDecimals = true;
                }
            }
            
            // Draw concentric circles
            for (let i = 1; i <= numCircles; i++) {
                const r = i * circleStep;
                // Check if this is a whole number (when decimals are being shown)
                const isWholeNumber = willShowDecimals && (Math.abs(r % 1) < 0.0001 || 
                    Math.abs(r - Math.round(r)) < 0.0001);
                
                // Make whole number circles darker when decimals are present
                if (isWholeNumber) {
                    ctx.strokeStyle = '#c0c0c0';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                }
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, (r / maxR) * radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Reset stroke style
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Draw radial lines (more angles: every 15Â°)
            for (let angle = 0; angle < 360; angle += 15) {
                const rad = (angle * Math.PI) / 180;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + radius * Math.cos(rad),
                    centerY + radius * Math.sin(rad)
                );
                ctx.stroke();
            }

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - radius, centerY);
            ctx.lineTo(centerX + radius, centerY);
            ctx.moveTo(centerX, centerY - radius);
            ctx.lineTo(centerX, centerY + radius);
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            const labelOffsetY = 6;
            ctx.fillText('0', centerX, centerY - labelOffsetY);
            
            // Adaptive decimal precision - no decimals until zoomed to about 2x
            // Cap at 1-2 decimals max for cleaner look
            let decimals = 0;
            
            // Only show decimals when zoomed in past about 2x
            if (willShowDecimals) {
                if (circleStep < 1) {
                    if (circleStep >= 0.1) {
                        decimals = 1;
                    } else if (circleStep >= 0.01) {
                        decimals = 2;
                    } else {
                        // For very small steps, cap at 2 decimals
                        decimals = 2;
                    }
                } else if (circleStep === 0.5) {
                    decimals = 1;
                } else if (circleStep >= 1 && circleStep < 10) {
                    decimals = 1;
                }
            }
            // Otherwise, keep decimals = 0 (whole numbers)
            
            for (let i = 1; i <= numCircles; i++) {
                const r = i * circleStep;
                const label = r.toFixed(decimals);
                ctx.fillText(label, centerX + (r / maxR) * radius, centerY - labelOffsetY);
            }
            
            // Update zoom info
            if (Math.abs(polarZoom - 1.0) < 0.01) {
                polarZoomInfo.textContent = `Auto-synced with cartesian | Scroll to adjust`;
            } else {
                polarZoomInfo.textContent = `Zoom: ${polarZoom.toFixed(2)}x (relative to cartesian)`;
            }

            // Plot the polar function
            ctx.strokeStyle = '#764ba2';
            ctx.lineWidth = 3;
            ctx.beginPath();

            let firstPoint = true;
            const step = 0.01;
            
            // Determine theta range:
            // - Pre-drawn mode: use current cartesian view (for full preview)
            // - Drawing mode: strictly use slider's [actualMin, sliderTheta] range
            const thetaView = getViewBounds();
            let thetaMin = thetaView.xMin;
            let thetaMax = thetaView.xMax;
            if (sliderMode === 'drawing') {
                const sliderEl = document.getElementById('thetaSlider');
                const actualMin = sliderEl ? parseFloat(sliderEl.dataset.actualMin || '0') : 0;
                const actualMax = sliderEl ? parseFloat(sliderEl.dataset.actualMax || (2 * Math.PI).toString()) : 2 * Math.PI;
                thetaMin = actualMin;
                thetaMax = Math.min(actualMax, Math.max(actualMin, sliderTheta));
            }

            for (let theta = thetaMin; theta <= thetaMax; theta += step) {
                try {
                    let expr = equation;
                    let r;

                    // Handle different variable cases
                    if (vars.hasR && vars.hasTheta) {
                        // r = f(theta) - replace theta, keep r as result
                        if (equation.includes('=')) {
                            const parts = equation.split('=');
                            if (parts.length === 2) {
                                const rightSide = parts[1].trim();
                                expr = rightSide.replace(/\btheta\b/g, `(${theta})`);
                            }
                        } else {
                            // Assume r is the result
                            expr = equation.replace(/\btheta\b/g, `(${theta})`);
                        }
                        r = math.evaluate(expr);
                    } else if (vars.hasX && !vars.hasTheta) {
                        // Treat x as theta
                        expr = equation.replace(/\bx\b/g, `(${theta})`);
                        r = math.evaluate(expr);
                    } else if (vars.hasTheta) {
                        // r = f(theta)
                        expr = equation.replace(/\btheta\b/g, `(${theta})`);
                        r = math.evaluate(expr);
                    } else {
                        // Default: treat x as theta
                        expr = equation.replace(/\bx\b/g, `(${theta})`);
                        r = math.evaluate(expr);
                    }

                    // Handle complex numbers
                    if (typeof r === 'object' && r.re !== undefined) {
                        r = r.re;
                    }

                    // Skip if r is invalid
                    if (isNaN(r) || !isFinite(r)) {
                        firstPoint = true;
                        continue;
                    }

                    // Convert polar to cartesian
                    // Note: Negative r means we go in the opposite direction
                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);

                    // Scale to canvas coordinates (extend to infinite range)
                    const plotX = centerX + (x / maxR) * radius;
                    const plotY = centerY - (y / maxR) * radius; // Negative because canvas Y is inverted

                    // Check bounds
                    if (plotX >= 0 && plotX <= width && plotY >= 0 && plotY <= height) {
                        if (firstPoint) {
                            ctx.moveTo(plotX, plotY);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(plotX, plotY);
                        }
                    } else {
                        firstPoint = true;
                    }
                } catch (error) {
                    firstPoint = true;
                }
            }

            ctx.stroke();

            // Draw point at slider position
            if (sliderTheta >= thetaMin && sliderTheta <= thetaMax) {
                try {
                    let expr = equation;
                    let r;

                    // Handle different variable cases
                    if (vars.hasR && vars.hasTheta) {
                        if (equation.includes('=')) {
                            const parts = equation.split('=');
                            if (parts.length === 2) {
                                const rightSide = parts[1].trim();
                                expr = rightSide.replace(/\btheta\b/g, `(${sliderTheta})`);
                            }
                        } else {
                            expr = equation.replace(/\btheta\b/g, `(${sliderTheta})`);
                        }
                        r = math.evaluate(expr);
                    } else if (vars.hasX && !vars.hasTheta) {
                        expr = equation.replace(/\bx\b/g, `(${sliderTheta})`);
                        r = math.evaluate(expr);
                    } else if (vars.hasTheta) {
                        expr = equation.replace(/\btheta\b/g, `(${sliderTheta})`);
                        r = math.evaluate(expr);
                    } else {
                        expr = equation.replace(/\bx\b/g, `(${sliderTheta})`);
                        r = math.evaluate(expr);
                    }

                    if (typeof r === 'object' && r.re !== undefined) {
                        r = r.re;
                    }

                    if (!isNaN(r) && isFinite(r)) {
                        // Convert polar to cartesian
                        const x = r * Math.cos(sliderTheta);
                        const y = r * Math.sin(sliderTheta);

                        // Scale to canvas coordinates
                        const plotX = centerX + (x / maxR) * radius;
                        const plotY = centerY - (y / maxR) * radius;

                        // Draw a subtler point
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.arc(plotX, plotY, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw a light border for visibility
                        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                } catch (error) {
                    // Ignore errors when drawing point
                }
            }
        }

        // Slider functions
        function setSliderMode(mode) {
            sliderMode = mode;
            document.getElementById('modePreDrawn').classList.toggle('active', mode === 'preDrawn');
            document.getElementById('modeDrawing').classList.toggle('active', mode === 'drawing');
            plotGraph();
        }

        function updateSliderRange() {
            const minInput = document.getElementById('sliderMin');
            const maxInput = document.getElementById('sliderMax');
            const minValue = minInput.value.trim();
            const maxValue = maxInput.value.trim();
            
            if (minValue === '') {
                sliderMin = null;
            } else {
                const num = parseFloat(minValue);
                if (!isNaN(num)) {
                    sliderMin = num;
                }
            }
            
            if (maxValue === '') {
                sliderMax = null;
            } else {
                const num = parseFloat(maxValue);
                if (!isNaN(num)) {
                    sliderMax = num;
                }
            }
            
            updateSliderBounds();
            plotGraph();
        }

        function updateSliderBounds() {
            const slider = document.getElementById('thetaSlider');
            const minLabel = document.getElementById('sliderMinLabel');
            const maxLabel = document.getElementById('sliderMaxLabel');
            
            // Determine actual min/max for slider
            let actualMin, actualMax;
            if (sliderMin !== null) {
                actualMin = sliderMin;
            } else {
                // Use periodicity if available, else default to [0, 2Ï€]
                const eq = equationInput.value.trim();
                const p = eq ? detectPeriodicity(preprocessEquation(eq)) : null;
                actualMin = 0;
                if (p && p.period && isFinite(p.period)) {
                    // keep min=0
                } else {
                    // keep min=0 for non-periodic too
                }
            }
            
            if (sliderMax !== null) {
                actualMax = sliderMax;
            } else {
                const eq = equationInput.value.trim();
                const p = eq ? detectPeriodicity(preprocessEquation(eq)) : null;
                if (p && p.period && isFinite(p.period)) {
                    actualMax = p.period;
                } else {
                    actualMax = 2 * Math.PI; // sensible default
                }
            }
            
            // Update slider min/max
            slider.min = 0;
            slider.max = 100;
            
            // Store the actual range for conversion
            slider.dataset.actualMin = actualMin;
            slider.dataset.actualMax = actualMax;
            
            // Update labels
            minLabel.textContent = `Min: ${formatTheta(actualMin)}`;
            maxLabel.textContent = `Max: ${formatTheta(actualMax)}`;
            
            // Update current theta based on slider position
            const sliderValue = parseFloat(slider.value);
            sliderTheta = actualMin + (sliderValue / 100) * (actualMax - actualMin);
            document.getElementById('sliderValue').textContent = `Î¸ = ${formatTheta(sliderTheta)}`;
        }

        function onSliderChange() {
            const slider = document.getElementById('thetaSlider');
            const actualMin = parseFloat(slider.dataset.actualMin || '-6.28');
            const actualMax = parseFloat(slider.dataset.actualMax || '6.28');
            const sliderValue = parseFloat(slider.value);
            
            sliderTheta = actualMin + (sliderValue / 100) * (actualMax - actualMin);
            document.getElementById('sliderValue').textContent = `Î¸ = ${formatTheta(sliderTheta)}`;
            
            plotGraph();
        }

        // Setup slider event listener
        function setupSlider() {
            const slider = document.getElementById('thetaSlider');
            if (slider) {
                slider.addEventListener('input', onSliderChange);
                updateSliderBounds();
            }
            attachSliderLabelEditors();
        }

        // Formatting Î¸ values; show clean multiples/fractions of Ï€ when close
        function formatTheta(value) {
            if (!isFinite(value)) return `${value}`;
            const eps = 1e-6;
            const k = value / Math.PI;
            if (Math.abs(k) < eps) return '0';
            const sign = k < 0 ? '-' : '';
            const ak = Math.abs(k);
            const denoms = [1, 2, 3, 4, 6, 8, 12];
            for (const d of denoms) {
                const n = Math.round(ak * d);
                if (Math.abs(ak - n / d) < eps) {
                    if (n === 0) return '0';
                    if (d === 1) {
                        if (n === 1) return `${sign}Ï€`;
                        return `${sign}${n}Ï€`;
                    }
                    if (n === 1) return `${sign}Ï€/${d}`;
                    return `${sign}${n}Ï€/${d}`;
                }
            }
            return value.toFixed(2);
        }

        // Allow click (or dblclick) editing of slider min/max labels inline
        function attachSliderLabelEditors() {
            const minLabel = document.getElementById('sliderMinLabel');
            const maxLabel = document.getElementById('sliderMaxLabel');
            if (minLabel) {
                minLabel.addEventListener('click', () => beginSliderLabelEdit('min'));
                minLabel.addEventListener('dblclick', () => beginSliderLabelEdit('min'));
            }
            if (maxLabel) {
                maxLabel.addEventListener('click', () => beginSliderLabelEdit('max'));
                maxLabel.addEventListener('dblclick', () => beginSliderLabelEdit('max'));
            }
        }

        function beginSliderLabelEdit(which) {
            const slider = document.getElementById('thetaSlider');
            const minLabel = document.getElementById('sliderMinLabel');
            const maxLabel = document.getElementById('sliderMaxLabel');
            const container = which === 'min' ? minLabel : maxLabel;
            if (!container || !slider) return;
            const current = which === 'min'
                ? parseFloat(slider.dataset.actualMin || '0')
                : parseFloat(slider.dataset.actualMax || (2 * Math.PI).toString());
            const input = document.createElement('input');
            input.type = 'text';
            input.value = formatTheta(current);
            input.style.width = '90px';
            input.style.fontSize = '0.9rem';
            input.style.padding = '2px 4px';
            input.style.borderRadius = '4px';
            input.style.border = '1px solid rgba(255,255,255,0.6)';
            // Replace label text temporarily
            const oldText = container.textContent;
            container.textContent = '';
            container.appendChild(input);
            input.focus();
            input.select();

            const cleanup = (apply) => {
                if (apply) {
                    const raw = input.value.trim();
                    const num = parseThetaExpression(raw);
                    if (num !== null && isFinite(num)) {
                        if (which === 'min') {
                            sliderMin = num;
                        } else {
                            sliderMax = num;
                        }
                        // Ensure min < max
                        if (sliderMin !== null && sliderMax !== null && sliderMin >= sliderMax) {
                            if (which === 'min') {
                                sliderMax = sliderMin + Math.max(Math.abs(sliderMin) * 0.1, 0.1);
                            } else {
                                sliderMin = sliderMax - Math.max(Math.abs(sliderMax) * 0.1, 0.1);
                            }
                        }
                        updateSliderBounds();
                        // Also re-render graphs if needed
                        plotGraph();
                    }
                }
                // Restore label text
                container.removeChild(input);
                // Refresh labels from current state
                const actualMin = parseFloat(slider.dataset.actualMin || '0');
                const actualMax = parseFloat(slider.dataset.actualMax || (2 * Math.PI).toString());
                if (which === 'min') {
                    minLabel.textContent = `Min: ${formatTheta(actualMin)}`;
                } else {
                    maxLabel.textContent = `Max: ${formatTheta(actualMax)}`;
                }
            };

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    cleanup(true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cleanup(false);
                }
            });
            input.addEventListener('blur', () => cleanup(true));
        }

        // Parse input like "pi", "2*pi", "1.5Ï€", "3.14"
        function parseThetaExpression(text) {
            if (!text) return null;
            try {
                // Normalize Ï€ and pi to mathjs 'pi'
                let expr = text.replace(/Ï€/gi, 'pi').replace(/PI/gi, 'pi');
                // Allow implicit multiplication like "2pi"
                expr = expr.replace(/(\d)\s*pi\b/gi, '$1*pi');
                const val = math.evaluate(expr);
                const num = typeof val === 'object' && val && val.re !== undefined ? val.re : val;
                return typeof num === 'number' ? num : null;
            } catch (e) {
                const direct = parseFloat(text);
                return isNaN(direct) ? null : direct;
            }
        }

        // Plot default equation on load
        window.addEventListener('load', () => {
            setupRangeInputListeners();
            setupSlider();
            const equation = equationInput.value.trim();
            if (equation) {
                autoSetRange(equation);
            }
            updateSliderBounds();
            plotGraph();
        });
        
        // Also setup listeners immediately if DOM is already ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setupRangeInputListeners();
                setupSlider();
            });
        } else {
            setupRangeInputListeners();
            setupSlider();
        }
    </script>
    <script src="function-helper.js"></script>
</body>
</html>

