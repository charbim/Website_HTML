<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinate Graph Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: #f6f7fb;
            min-height: 100vh;
            padding: 1.5rem;
            color: #111827;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
        }

        .function-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            margin-left: auto; /* push to the right edge */
        }

        .function-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 5px;
            padding: 0.4rem 0.8rem;
            color: #111827;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            text-align: center;
        }

        .function-btn:hover {
            background: #f3f4f6;
            transform: scale(1.05);
        }

        .function-group {
            display: flex;
            gap: 0.3rem;
            align-items: center;
        }

        .function-group-label {
            font-size: 0.85rem;
            color: #6b7280;
            margin-right: 0.3rem;
        }

        h1 {
            text-align: center;
            font-size: 1.75rem;
            margin-bottom: 0.75rem;
        }

        .input-section {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 0.9rem;
            margin-bottom: 0.75rem;
            box-shadow: 0 1px 2px rgba(16, 24, 40, 0.06);
        }

        /* Condense and center the equation bar card */
        .equation-bar {
            width: 100%;
            margin: 0;
        }

        .equation-stack {
            width: 100%;
            margin: 0 0 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .equation-card {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .equation-heading {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .eyebrow-label {
            font-size: 0.75rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 700;
            color: #dc2626; /* red titles per style guide */
        }

        .helper-text {
            font-size: 0.85rem;
            color: #6b7280;
        }

        .equation-field {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 100%;
            position: relative;
        }

        .equation-field input[type="text"] {
            flex: 1;
            min-width: 0;
        }

        /* Inline color overlay for equation input */
        .equation-color-overlay {
            position: absolute;
            pointer-events: none;
            top: 0;
            left: 0;
            width: 0; /* will be set by JS */
            height: 0; /* will be set by JS */
            overflow: hidden;
            white-space: nowrap;
            color: #111827;
            font: inherit;
        }
        .equation-field.overlay-active #equation {
            color: transparent; /* hide raw text while showing colored overlay */
            caret-color: #111827; /* keep caret visible */
        }

        .equation-actions {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .secondary-btn {
            background: #f9fafb;
            border: 1px solid #d1d5db;
            color: #111827;
        }

        .secondary-btn:hover {
            background: #f3f4f6;
            border-color: #cbd5f5;
            color: #111827;
        }
        
        .eq-symbol {
            font-weight: 700;
            color: #111827;
        }

        .mini-slider-panel {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .mini-slider-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .mini-slider-grid {
            display: grid;
            gap: 0.75rem;
        }

        @media (min-width: 720px) {
            .mini-slider-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        .mini-slider {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.75rem;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            background: #f9fafb;
        }

        .mini-slider label {
            font-size: 0.95rem;
            font-weight: 600;
            color: #dc2626; /* style guide red for titles */
        }

        .mini-slider-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.6rem;
        }

        .mini-slider-value {
            flex: 0 0 90px;
            width: 90px;
            min-width: 0;
            padding: 0.45rem 0.6rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.9rem;
            background: #ffffff;
        }

        .mini-slider-range {
            flex: 1;
        }

        .mini-slider-bounds {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.85rem;
            color: #111827;
            margin-top: 0.15rem;
        }

        .mini-slider-bounds .value,
        .mini-slider-bounds input.mini-bound-input {
            box-sizing: border-box;
            font-weight: 600;
            color: #111827;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 4px 8px;
            min-width: 70px;
            text-align: center;
        }
        .mini-slider-bounds input.mini-bound-input {
            cursor: text;
            outline: none;
        }
        .mini-slider-bounds input.mini-bound-input:hover {
            border-color: #d1d5db;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
        }
        .mini-slider-bounds input.mini-bound-input:focus {
            border-color: rgba(220, 38, 38, 0.65);
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.15);
        }

        .toggle-panel {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .toggle-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .toggle-grid {
            display: grid;
            gap: 0.5rem;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .toggle-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.45rem 0.5rem;
            border: 1px dashed #e5e7eb;
            border-radius: 8px;
            background: #f9fafb;
        }

        .toggle-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        /* Distinct colors for toggles and matching equation tokens - muted/toned down */
        #toggleTheta { accent-color: #9333ea; }
        #toggleTheta + span { color: #9333ea; font-weight: 600; }
        #toggleRadius { accent-color: #dc2626; }
        #toggleRadius + span { color: #dc2626; font-weight: 600; }
        #toggleAmp { accent-color: #ea580c; }
        #toggleAmp + span { color: #ea580c; font-weight: 600; }
        #toggleFreq { accent-color: #16a34a; }
        #toggleFreq + span { color: #16a34a; font-weight: 600; }
        #toggleShifts { accent-color: #ca8a04; }
        #toggleShifts + span { color: #ca8a04; font-weight: 600; }
        #toggleColorRadius { accent-color: #0ea5e9; }
        #toggleColorRadius + span { color: #0ea5e9; font-weight: 600; }

        .equation-pretty .token-theta,
        .equation-color-overlay .token-theta { color: #9333ea; font-weight: 700; }
        .equation-pretty .token-r,
        .equation-color-overlay .token-r { color: #dc2626; font-weight: 700; }
        .equation-pretty .token-amp,
        .equation-color-overlay .token-amp { color: #ea580c; font-weight: 700; }
        .equation-pretty .token-freq,
        .equation-color-overlay .token-freq { color: #16a34a; font-weight: 700; }
        .equation-pretty .token-shift,
        .equation-color-overlay .token-shift { color: #facc15; font-weight: 700; }

        /* Hide the pretty-preview line under the equation input (keep the live input overlay) */
        #equationPretty { display: none; }

        .toggle-hint {
            font-size: 0.85rem;
            color: #6b7280;
        }

        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            font-size: 1.2rem;
            font-weight: bold;
        }

        input[type="text"] {
            flex: 1;
            min-width: 300px;
            padding: 0.8rem 1.2rem;
            font-size: 1.1rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #ffffff;
            color: #111827;
            outline: none;
            transition: all 0.3s ease;
        }

        .mini-slider .mini-slider-value {
            flex: 0 0 90px;
            width: 90px;
            min-width: 0;
        }

        input[type="text"]:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
        }

        input[type="text"]::placeholder {
            color: #6b7280;
        }

        button {
            padding: 0.6rem 1rem;
            font-size: 1rem;
            background: #dc2626; /* red-600 */
            border: 1px solid #dc2626;
            border-radius: 8px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        button:hover {
            background: #b91c1c; /* red-700 */
            border-color: #b91c1c;
            box-shadow: 0 1px 2px rgba(16, 24, 40, 0.06);
        }

        .examples {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #374151;
        }

        .examples strong {
            color: #111827;
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            align-items: stretch;
            margin-top: 1.5rem;
        }

        .graph-section {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .graph-top-panel {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* 3-column toolbar: equation | mode buttons | reset (above the graphs) */
        .graph-toolbar-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.75rem;
            align-items: center;
            justify-items: center; /* center contents within each column */
        }
        .graph-toolbar-row > .equation-stack {
            justify-self: center;
            margin: 0;
            width: 100%;
        }
        .graph-toolbar-row > .mode-toolbar {
            justify-self: center;
            margin: 0;
            justify-content: center;
        }
        .graph-toolbar-row > .graph-reset {
            justify-self: center;
            margin: 0;
            text-align: center;
        }
        /* Make the equation card hug its contents (instead of filling the whole column) */
        .graph-toolbar-row .equation-centered {
            max-width: none;
            margin: 0;
        }
        .graph-toolbar-row .equation-bar {
            width: fit-content;
            max-width: 100%;
            margin-bottom: 0;
            padding: 0.65rem 0.75rem;
        }
        .graph-toolbar-row .equation-field {
            width: auto;
        }
        .graph-toolbar-row .function-menu {
            margin-left: 0; /* don't force the buttons to the far edge inside the compact card */
        }
        .graph-toolbar-row .graph-reset .control-btn {
            min-width: auto;
            white-space: nowrap;
        }

        .graphs-container {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            align-items: stretch;
        }

        @media (max-width: 1100px) {
            .graphs-container {
                flex-direction: column;
            }
            .graph-toolbar-row {
                grid-template-columns: 1fr;
                justify-items: stretch;
            }
            .graph-toolbar-row > .mode-toolbar,
            .graph-toolbar-row > .graph-reset {
                justify-self: start;
                text-align: left;
            }
        }

        .graph-wrapper {
            flex: 1;
            min-width: 0;
        }

        .graph-reset {
            text-align: center;
            margin-top: 0.25rem;
        }

        .graph-reset .control-btn {
            min-width: 180px;
        }

        .graph-wrapper {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 0.5rem;
            box-shadow: 0 1px 2px rgba(16, 24, 40, 0.04);
            position: relative;
            aspect-ratio: 1 / 1;
        }

        .control-btn {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            background: #dc2626;
            border: 1px solid #dc2626;
            border-radius: 5px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: #b91c1c;
            border-color: #b91c1c;
        }

        canvas {
            width: 100%;
            background: #ffffff;
            border-radius: 10px;
            cursor: crosshair;
            aspect-ratio: 1 / 1;
            height: auto;
            display: block;
        }
        .equation-centered {
            max-width: 960px;
            width: 100%;
            margin: 0 auto;
        }
        .tabbed-controls {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 0.75rem;
            box-shadow: 0 1px 2px rgba(16, 24, 40, 0.05);
        }
        .tab-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .tab-button {
            flex: 1;
            padding: 0.65rem 0.75rem;
            background: #ffffff;
            border: 1px solid #fecaca; /* red-200 */
            border-radius: 8px;
            font-weight: 700;
            color: #b91c1c; /* red-700 */
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
        }
        .tab-button:hover {
            background: #fef2f2; /* red-50 */
            border-color: #fca5a5; /* red-300 */
        }
        .tab-button.active {
            background: #dc2626; /* red-600 */
            border-color: #dc2626;
            color: #ffffff;
            box-shadow: 0 1px 2px rgba(16, 24, 40, 0.06);
        }

        /* Make the "Reset" buttons in the bottom Sliders/Toggles panels match the red theme */
        .tabbed-controls .secondary-btn {
            background: #ffffff;
            border: 1px solid #fecaca; /* red-200 */
            color: #b91c1c; /* red-700 */
        }
        .tabbed-controls .secondary-btn:hover {
            background: #fef2f2; /* red-50 */
            border-color: #b91c1c; /* red-700 */
            color: #b91c1c;
        }
        .tabbed-controls .secondary-btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }
        .tab-panels {
            position: relative;
        }
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }

        #cartesianCanvas {
            cursor: grab;
        }

        #cartesianCanvas.dragging {
            cursor: grabbing;
        }

        .error-message {
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            color: #111827;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        @media (max-width: 1024px) {
            h1 {
                font-size: 1.75rem;
            }

            .input-group {
                flex-direction: column;
            }

            input[type="text"] {
                width: 100%;
                min-width: auto;
            }
            
            #rangeSection .input-group {
                grid-template-columns: 1fr 1fr !important;
            }
        }
        
        @media (max-width: 600px) {
            #rangeSection .input-group {
                grid-template-columns: 1fr !important;
            }
        }

        .slider-section {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 0.75rem 1rem;
            margin-top: 0.75rem;
            margin-bottom: 0.75rem;
            box-shadow: 0 1px 2px rgba(16, 24, 40, 0.06);
            /* Don't let the white panel stretch full-width; shrink to fit slider section */
            width: fit-content;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
            align-self: center;
        }

        .edit-adjust-buttons {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            box-shadow: 0 1px 2px rgba(16, 24, 40, 0.06);
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .adjust-btn {
            padding: 0.6rem 1.2rem;
            font-size: 0.95rem;
            background: #ffffff;
            border: 2px solid #dc2626;
            border-radius: 8px;
            color: #dc2626;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .adjust-btn:hover {
            background: #fef2f2;
            border-color: #b91c1c;
            color: #b91c1c;
        }

        .adjust-btn.active {
            background: #dc2626;
            border-color: #dc2626;
            color: #ffffff;
        }

        /* Hide verbose header in slider area to make it compact */
        .slider-section h3,
        .slider-section p {
            display: none;
        }

        .slider-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.5rem;
            justify-content: center;
        }

        .slider-mode-toggle {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
        }

        .mode-btn {
            padding: 0.45rem 0.9rem;
            font-size: 0.9rem;
            background: #ffffff;
            border: 1px solid #fecaca; /* red-200 */
            border-radius: 8px;
            color: #b91c1c; /* red-700 */
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #dc2626; /* red-600 */
            border-color: #dc2626;
            color: #ffffff;
            font-weight: bold;
        }

        .mode-btn:hover {
            background: #fef2f2; /* red-50 */
        }

        .slider-range-inputs {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .slider-range-inputs input[type="number"] {
            width: 120px;
            padding: 0.6rem;
            font-size: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #ffffff;
            color: #111827;
        }

        .slider-range-inputs label {
            font-size: 0.9rem;
            margin-right: 0.3rem;
        }

        .slider-container {
            margin-top: 0.25rem;
            /* Preserve current theta slider size while letting the panel shrink-wrap */
            width: 640px;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
        }

        .slider-wrapper {
            position: relative;
            margin: 0.25rem 0;
        }

        /* Normalize all range inputs so every slider has the same track/thickness (fixes inconsistent UA rendering) */
        input[type="range"] {
            width: 100%;
            background: transparent;
            outline: none;
            padding: 0;
            margin: 0;
            height: 20px; /* comfortable hit area; actual track height is set below */
            -webkit-appearance: none;
            appearance: none;
        }

        /* WebKit */
        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: #e5e7eb;
            border-radius: 999px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 999px;
            background: #dc2626; /* red thumb */
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            margin-top: -4px; /* center thumb on 4px track: (4 - 12) / 2 */
        }

        /* Firefox */
        input[type="range"]::-moz-range-track {
            height: 4px;
            background: #e5e7eb;
            border-radius: 999px;
        }
        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 999px;
            background: #dc2626; /* red thumb */
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]:focus-visible::-webkit-slider-thumb,
        
        /* Theta slider: thicker track + more square knob for easier interaction */
        #thetaSlider::-webkit-slider-runnable-track {
            height: 10px;
            background: #d1d5db;
            border-radius: 8px;
        }
        #thetaSlider::-webkit-slider-thumb {
            width: 20px;
            height: 20px;
            border-radius: 5px; /* more square */
            background: #dc2626;
            border: 2px solid rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
            margin-top: -5px; /* center thumb on 10px track: (10 - 20) / 2 */
        }
        #thetaSlider::-moz-range-track {
            height: 10px;
            background: #d1d5db;
            border-radius: 8px;
        }
        #thetaSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 5px;
            background: #dc2626;
            border: 2px solid rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
        }
        input[type="range"]:focus-visible::-moz-range-thumb {
            box-shadow: 0 0 0 4px rgba(220, 38, 38, 0.18), 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .slider-value {
            text-align: center;
            font-size: 0.95rem;
            font-weight: bold;
            margin-top: 0.25rem;
            color: #374151;
        }

        /* Theta slider: show min/max boxes directly beside the slider */
        .theta-slider-row {
            display: grid;
            grid-template-columns: 34px 1fr 34px;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.1rem;
            width: 100%;
        }
        .theta-slider-row input[type="range"] {
            width: 100%;
            min-width: 0;
        }
        /* Use higher specificity than input[type="text"] so we override global text input styling */
        .theta-slider-row input[type="text"].theta-bound-input {
            box-sizing: border-box;
            width: 34px;
            min-width: 34px;
            max-width: 34px;
            height: 34px;
            padding: 0;
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
            background: #f9fafb;
            color: #111827;
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            flex: 0 0 auto;
        }
        .theta-slider-row input[type="text"].theta-bound-input:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
        }
        .theta-slider-row input[type="text"].theta-bound-input:focus {
            outline: none;
            border-color: rgba(220, 38, 38, 0.65);
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.15);
            background: #ffffff;
        }

        .slider-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        /* Make slider min/max values look editable and obvious */
        .slider-info .value {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 3px 6px;
            cursor: text !important;
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            color: #111827;
        }
        .slider-info .value:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
        }
        .slider-bound {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .slider-bound .label {
            opacity: 0.9;
        }
        /* Hide ALL mini function buttons under the equation input */
        .function-menu {
            display: none;
        }
        /* Compact parameter sliders below graphs */
        .param-sliders {
            margin-top: 0.25rem;
        }
        .param-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.75rem;
        }
        .param {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .param-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }
        .param label {
            font-size: 0.9rem;
            color: #374151;
        }
        .param-header input[type="number"],
        .param-header input[type="text"] {
            width: 100px;
            padding: 0.4rem 0.5rem;
            font-size: 0.9rem;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: #f9fafb;
            color: #111827;
        }
        .param input[type="range"] {
            width: 100%;
        }
        .param .param-value {
            font-size: 0.9rem;
            color: #111827;
            text-align: right;
        }
        .param .param-slider-wrapper {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .param .param-info {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
        }
        .param-actions {
            margin-top: 0.25rem;
            display: flex;
            justify-content: flex-end;
        }
        @media (max-width: 900px) {
            .param-grid {
                grid-template-columns: repeat(1, minmax(0, 1fr));
            }
        }
        /* Try to normalize any function helper tab injected by external script */
        #functionHelperTab, .function-helper-tab, .function-tab {
            position: fixed !important;
            right: 0 !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            background: #1f1f1f !important;
            color: #fff !important;
            padding: 10px 8px !important;
            border-radius: 8px 0 0 8px !important;
            z-index: 2000 !important;
            white-space: nowrap;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }
        .r-prefix {
            display: inline-flex;
            align-items: baseline;
            gap: 2px;
            padding: 0.2rem 0.4rem;
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
        }
        .r-prefix:hover {
            background: #f3f4f6;
        }
        .r-prefix sup {
            font-size: 0.75em;
            margin-left: 1px;
        }
        .r-exp-input {
            width: 2.4em;
            font-size: 0.8rem;
            background: transparent;
            border: none;
            border-bottom: 1px solid #9ca3af;
            color: #111827;
            text-align: center;
            outline: none;
        }
        .r-exp-menu {
            position: absolute;
            background: rgba(31, 31, 31, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 8px;
            padding: 6px;
            z-index: 3000;
            box-shadow: 0 6px 16px rgba(0,0,0,0.35);
            backdrop-filter: blur(8px);
        }
        .r-exp-option {
            padding: 6px 10px;
            color: white;
            cursor: pointer;
            border-radius: 6px;
            white-space: nowrap;
            user-select: none;
            font-weight: 600;
        }
        .r-exp-option:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        /* Constrain the equation input so it doesn't span full width */
        #equation {
            flex: 0 1 auto;
            width: clamp(300px, 36vw, 560px);
        }
        /* Pretty math preview styling */
        .equation-pretty {
            margin-top: 0.35rem;
            color: #ffffff;
            font-size: 0.95rem;
            user-select: none;
        }
        .pretty-math .frac {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            vertical-align: middle;
            margin: 0 2px;
        }
        .pretty-math .frac .num,
        .pretty-math .frac .den {
            padding: 0 2px;
            line-height: 1.1;
        }
        .pretty-math .frac .bar {
            align-self: stretch;
            border-top: 2px solid currentColor;
            margin: 0.05em 0;
        }
        /* Interaction mode toolbar */
        .mode-toolbar {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
            margin: 0.25rem 0 0.75rem;
        }
        .icon-btn {
            width: 34px;
            height: 34px;
            border-radius: 8px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.08s ease, border-color 0.2s ease;
            position: relative;
        }
        .icon-btn:hover {
            background: #eef2ff;
            transform: translateY(-1px);
            border-color: #dbeafe;
        }
        .icon-btn.active {
            background: #e0e7ff;
            border-color: #c7d2fe;
        }
        .icon-btn svg {
            width: 18px;
            height: 18px;
            fill: #374151;
            color: #374151;
        }
        .icon-btn.active svg {
            fill: #4338ca;
            color: #4338ca;
        }
        /* Tooltip for icon buttons (JS adds .show-tip after ~600ms hover) */
        .icon-tooltip {
            position: absolute;
            pointer-events: none;
            white-space: nowrap;
            background: rgba(17,24,39,0.95);
            color: #fff;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 6px;
            transform: translate(-50%, -8px);
            top: -6px;
            left: 50%;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        .icon-btn.show-tip .icon-tooltip {
            opacity: 1;
        }
        /* Hover coordinate tooltip (for View mode) */
        .hover-tooltip {
            position: fixed;
            z-index: 2000;
            pointer-events: none;
            background: rgba(17,24,39,0.92);
            color: #ffffff;
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 6px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.25);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“Š Coordinate Graph Visualizer</h1>
        
        <!-- Equation bar moved into the top panel (swapped with theta slider) -->

        <div class="input-section" id="rangeSection" style="display: none;">
            <div style="margin-bottom: 1rem;">
                <h3 style="font-size: 1.3rem; margin-bottom: 0.5rem;">Adjust Range</h3>
                <p style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.8); margin-bottom: 1rem;">
                    Manually set the bounds for both graphs. Leave empty to use auto-detected range.
                </p>
            </div>
            <div class="input-group" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem;">
                <div>
                    <label for="xMin" style="font-size: 0.9rem; display: block; margin-bottom: 0.3rem;">Î¸ Min:</label>
                    <input type="number" id="xMin" placeholder="Auto" step="any" style="width: 100%; padding: 0.6rem; font-size: 1rem;">
                </div>
                <div>
                    <label for="xMax" style="font-size: 0.9rem; display: block; margin-bottom: 0.3rem;">Î¸ Max:</label>
                    <input type="number" id="xMax" placeholder="Auto" step="any" style="width: 100%; padding: 0.6rem; font-size: 1rem;">
                </div>
                <div>
                    <label for="yMin" style="font-size: 0.9rem; display: block; margin-bottom: 0.3rem;">r Min:</label>
                    <input type="number" id="yMin" placeholder="Auto" step="any" style="width: 100%; padding: 0.6rem; font-size: 1rem;">
                </div>
                <div>
                    <label for="yMax" style="font-size: 0.9rem; display: block; margin-bottom: 0.3rem;">r Max:</label>
                    <input type="number" id="yMax" placeholder="Auto" step="any" style="width: 100%; padding: 0.6rem; font-size: 1rem;">
                </div>
            </div>
            <div style="margin-top: 1rem; display: flex; gap: 0.5rem;">
                <button onclick="resetRangeToAuto()" style="padding: 0.6rem 1.5rem; font-size: 0.95rem;">Reset to Auto</button>
                <button onclick="toggleRangeSection()" style="padding: 0.6rem 1.5rem; font-size: 0.95rem;">Hide Range Controls</button>
            </div>
        </div>


        <div class="main-layout">
            <div class="graph-section">
                <div class="graph-top-panel">
                    <!-- Edit Mode Adjustment Buttons -->
                    <div class="edit-adjust-buttons" id="editAdjustButtons" style="display: none;">
                        <button class="adjust-btn" id="btnAmplitudeAdjust" onclick="activateAdjustMode('amplitude')">Amplitude adjust</button>
                        <button class="adjust-btn" id="btnFrequencyAdjust" onclick="activateAdjustMode('frequency')">Frequency adjust</button>
                        <button class="adjust-btn" id="btnShiftAdjust" onclick="activateAdjustMode('shift')">Shift adjust</button>
                    </div>
                    <div class="graph-toolbar-row">
                        <div class="equation-stack equation-centered">
                            <!-- Equation bar -->
                            <div class="input-section equation-bar equation-card">
                                <div class="equation-heading">
                                    <div>
                                        <label for="equation" class="eyebrow-label">Equation</label>
                                        <p class="helper-text">Write r in terms of Î¸ or x. Type <b>sqrt</b> for âˆš( ) and <b>abs</b> or <b>|</b> for | |.</p>
                                    </div>
                                </div>
                                <div class="equation-field">
                                    <span id="rPrefix" class="r-prefix" title="Click to choose r, rÂ², or rÂ³">r<sup id="rExp" style="display:none"></sup></span>
                                    <span class="eq-symbol">=</span>
                                    <input type="text" id="equation" placeholder="Enter equation (e.g., sin(Î¸), âˆš(Î¸), |Î¸|)" value="sin(Î¸)">
                                </div>
                                <div id="equationPretty" class="equation-pretty pretty-math" aria-hidden="true"></div>
                                <div class="error-message" id="errorMessage"></div>
                            </div>
                        </div>
                        <div class="mode-toolbar" id="interactionToolbar">
                            <button id="btnModePerspective" class="icon-btn active" onclick="setInteractionMode('perspective')" aria-label="Move mode">
                                <!-- plus + arrow icon -->
                                <svg viewBox="0 0 24 24" aria-hidden="true">
                                    <rect x="11" y="5" width="2" height="14"/>
                                    <rect x="5" y="11" width="14" height="2"/>
                                    <path d="M14 7l5 5-5 5v-4h-4v-2h4z"/>
                                </svg>
                                <span class="icon-tooltip">Move mode</span>
                            </button>
                            <button id="btnModeView" class="icon-btn" onclick="setInteractionMode('view')" aria-label="View mode">
                                <!-- new eye icon -->
                                <svg viewBox="0 0 48 48" aria-hidden="true" preserveAspectRatio="xMidYMid meet">
                                    <path d="M4 24c4-8 12-14 20-14s16 6 20 14c-4 8-12 14-20 14S8 32 4 24Z" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
                                    <circle cx="24" cy="24" r="8" fill="currentColor"/>
                                    <path d="M12 6l5 8" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
                                    <path d="M24 4v10" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
                                    <path d="M36 6l-5 8" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
                                </svg>
                                <span class="icon-tooltip">View mode</span>
                            </button>
                            <button id="btnModeEdit" class="icon-btn" onclick="setInteractionMode('edit')" aria-label="Graph edit mode">
                                <!-- wrench icon -->
                                <svg viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M22.7 19.3l-6.4-6.4a6 6 0 0 1-7.6-7.6l3.2 3.2 2.1-2.1-3.2-3.2a6 6 0 0 1 7.6 7.6l6.4 6.4-2.1 2.1zM2 22l6.1-1.6L3.6 15.9 2 22z"/>
                                </svg>
                                <span class="icon-tooltip">Graph edit mode</span>
                            </button>
                        </div>
                        <div class="graph-reset">
                            <button id="resetGraphsBtn" class="control-btn" type="button">Reset</button>
                        </div>
                    </div>
                </div>
                <div class="graphs-container">
                    <div class="graph-wrapper">
                        <canvas id="cartesianCanvas"></canvas>
                    </div>
                    <div class="graph-wrapper">
                        <canvas id="polarCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="slider-section" id="sliderSection">
            <div style="margin-bottom: 1rem;">
                <h3 style="font-size: 1.3rem; margin-bottom: 0.5rem; color: #dc2626;">Theta Slider</h3>
                <p style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.8); margin-bottom: 1rem;">
                    Move the slider to see the point on both graphs. Choose between pre-drawn mode (dot travels) or drawing mode (graph draws as you move).
                </p>
            </div>
            <div class="slider-controls">
                <div class="slider-mode-toggle">
                    <button class="mode-btn active" id="modePreDrawn" onclick="setSliderMode('preDrawn')">Pre-drawn</button>
                    <button class="mode-btn" id="modeDrawing" onclick="setSliderMode('drawing')">Drawing</button>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-wrapper">
                    <div class="theta-slider-row">
                        <input id="sliderMinLabel" class="theta-bound-input" type="text" value="0" inputmode="decimal" aria-label="Theta minimum" title="Set Î¸ min (supports Ï€)">
                        <input type="range" id="thetaSlider" min="0" max="100" value="0" step="0.01">
                        <input id="sliderMaxLabel" class="theta-bound-input" type="text" value="0" inputmode="decimal" aria-label="Theta maximum" title="Set Î¸ max (supports Ï€)">
                    </div>
                    <div class="slider-value" id="sliderValue">Î¸ = 0.00</div>
                </div>
            </div>
        </div>

        <div class="tabbed-controls">
            <div class="tab-buttons">
                <button class="tab-button active" data-tab-target="slidersTab">Sliders</button>
                <button class="tab-button" data-tab-target="togglesTab">Toggles</button>
            </div>
            <div class="tab-panels">
                <div class="tab-panel active" id="slidersTab">
                    <!-- Parameter sliders -->
                    <div class="input-section mini-slider-panel" id="paramSliderSection">
                        <div class="mini-slider-header">
                            <div>
                                <div class="eyebrow-label">Sliders</div>
                                <p class="helper-text">Fine-tune amplitude, frequency, and shifts.</p>
                            </div>
                            <button id="resetParamsBtn" class="secondary-btn" type="button">Reset</button>
                        </div>
                        <div class="mini-slider-grid">
                            <!-- Amp -->
                            <div class="mini-slider" data-param="amp">
                                <div class="mini-slider-top">
                                    <label for="ampSlider">Amplitude</label>
                                    <input type="text" id="ampInput" value="1" class="mini-slider-value" inputmode="text" aria-label="Amplitude" title="Type a value/expression (supports Ï€)">
                                </div>
                                <input type="range" id="ampSlider" min="-5" max="5" step="any" value="1" class="mini-slider-range">
                                <div class="mini-slider-bounds">
                                    <input id="ampMinLabel" class="mini-bound-input" type="text" value="-5.00" inputmode="text" aria-label="Amplitude minimum" title="Set min (supports Ï€)">
                                    <input id="ampMaxLabel" class="mini-bound-input" type="text" value="5.00" inputmode="text" aria-label="Amplitude maximum" title="Set max (supports Ï€)">
                                </div>
                            </div>
                            <!-- X Shift -->
                            <div class="mini-slider" data-param="xShift">
                                <div class="mini-slider-top">
                                    <label for="xShiftSlider">x-shift</label>
                                    <input type="text" id="xShiftInput" value="0" class="mini-slider-value">
                                </div>
                                <!-- Use step="any" so exact values like 0 and 5 are representable (avoids Â±0.003 drift from min/step misalignment). -->
                                <input type="range" id="xShiftSlider" min="-6.283185307179586" max="6.283185307179586" step="any" value="0" class="mini-slider-range">
                                <div class="mini-slider-bounds">
                                    <input id="xShiftMinLabel" class="mini-bound-input" type="text" value="-2Ï€" inputmode="text" aria-label="x-shift minimum" title="Set min (supports Ï€)">
                                    <input id="xShiftMaxLabel" class="mini-bound-input" type="text" value="2Ï€" inputmode="text" aria-label="x-shift maximum" title="Set max (supports Ï€)">
                                </div>
                            </div>
                            <!-- Frequency -->
                            <div class="mini-slider" data-param="freq">
                                <div class="mini-slider-top">
                                    <label for="freqSlider">Frequency</label>
                                    <input type="text" id="freqInput" value="1" class="mini-slider-value" inputmode="text" aria-label="Frequency" title="Type a value/expression (supports Ï€)">
                                </div>
                                <input type="range" id="freqSlider" min="0.05" max="20" step="any" value="1" class="mini-slider-range">
                                <div class="mini-slider-bounds">
                                    <input id="freqMinLabel" class="mini-bound-input" type="text" value="0.05" inputmode="text" aria-label="Frequency minimum" title="Set min (supports Ï€)">
                                    <input id="freqMaxLabel" class="mini-bound-input" type="text" value="20.00" inputmode="text" aria-label="Frequency maximum" title="Set max (supports Ï€)">
                                </div>
                            </div>
                            <!-- Y Shift -->
                            <div class="mini-slider" data-param="yShift">
                                <div class="mini-slider-top">
                                    <label for="yShiftSlider">y-shift</label>
                                    <input type="text" id="yShiftInput" value="0" class="mini-slider-value" inputmode="text" aria-label="y-shift" title="Type a value/expression (supports Ï€)">
                                </div>
                                <input type="range" id="yShiftSlider" min="-10" max="10" step="any" value="0" class="mini-slider-range">
                                <div class="mini-slider-bounds">
                                    <input id="yShiftMinLabel" class="mini-bound-input" type="text" value="-10.00" inputmode="text" aria-label="y-shift minimum" title="Set min (supports Ï€)">
                                    <input id="yShiftMaxLabel" class="mini-bound-input" type="text" value="10.00" inputmode="text" aria-label="y-shift maximum" title="Set max (supports Ï€)">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="tab-panel" id="togglesTab">
                    <div class="input-section toggle-panel">
                        <div class="toggle-header">
                            <div>
                                <div class="eyebrow-label">Toggles</div>
                                <p class="helper-text">Preview upcoming controls.</p>
                            </div>
                            <button type="button" class="secondary-btn" id="toggleResetBtn" disabled>Reset</button>
                        </div>
                        <div class="toggle-grid">
                            <label class="toggle-item" for="toggleTheta">
                                <input type="checkbox" id="toggleTheta">
                                <span>Theta</span>
                            </label>
                            <label class="toggle-item" for="toggleAmp">
                                <input type="checkbox" id="toggleAmp">
                                <span>Amplitude</span>
                            </label>
                            <label class="toggle-item" for="toggleShifts">
                                <input type="checkbox" id="toggleShifts">
                                <span>Shifts</span>
                            </label>
                            <label class="toggle-item" for="toggleRadius">
                                <input type="checkbox" id="toggleRadius">
                                <span>Radius</span>
                            </label>
                            <label class="toggle-item" for="toggleFreq">
                                <input type="checkbox" id="toggleFreq">
                                <span>Frequency</span>
                            </label>
                            <label class="toggle-item" for="toggleColorRadius">
                                <input type="checkbox" id="toggleColorRadius">
                                <span>Color-coded radius</span>
                            </label>
                        </div>
                        <p class="toggle-hint">These toggles are visual placeholders for now.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const cartesianCanvas = document.getElementById('cartesianCanvas');
        const polarCanvas = document.getElementById('polarCanvas');
        const equationInput = document.getElementById('equation');
        const errorMessage = document.getElementById('errorMessage');

        // Pan and zoom state
        let cartesianZoom = 1.0;
        let cartesianCenterX = 0;
        let cartesianCenterY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let polarZoom = 1.0;
        // Interaction modes
        let interactionMode = 'perspective'; // 'perspective' | 'view' | 'edit'
        let tooltipEl = null;
        let tooltipTimer = null;
        let lastPolarState = { centerX: 0, centerY: 0, maxR: 1, radiusPx: 1 };
        // Edit mode state
        let editBaseEquation = '';
        let editParams = { amplitude: 1, frequency: 1, thetaShift: 0, rShift: 0 };
        let isEditTranslating = false;
        let isEditAdjustingAmplitude = false;
        let isEditAdjustingFrequency = false;
        let editStart = null;
        let editLockedMaxR = null; // keep polar scale steady during edit
        let lastEditMouseWorld = null; // track current mouse world coords in edit mode
        let editAdjustMode = 'shift'; // 'amplitude' | 'frequency' | 'shift' - default to shift
        
        // Manual range bounds (null means auto)
        let manualXMin = null;
        let manualXMax = null;
        let manualYMin = null;
        let manualYMax = null;

        // Slider state
        let sliderMode = 'preDrawn'; // 'preDrawn' or 'drawing'
        let currentTheta = 0;
        let sliderMin = null; // null means use manualXMin or auto
        let sliderMax = null; // null means use manualXMax or auto
        let sliderTheta = 0; // Current slider theta value
        // UI exponent for r (used when equation does not explicitly include r on the left)
        let uiRExponent = 1;
        // Tab control state
        let tabsInitialized = false;
        // Param slider session flags
        let sliderSessionActive = false;
        let updatingEquationFromSliders = false;
        // Default view memory
        let defaultCartesianBounds = null;
        let defaultPolarZoom = null;

        function rememberDefaultCartesianView(force = false) {
            if (!force && defaultCartesianBounds) return;
            defaultCartesianBounds = getViewBounds();
        }

        function rememberDefaultPolarZoom(force = false) {
            if (!force && defaultPolarZoom !== null) return;
            defaultPolarZoom = polarZoom;
        }

        function initBottomTabs() {
            if (tabsInitialized) return;
            tabsInitialized = true;
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');
            tabButtons.forEach((btn) => {
                btn.addEventListener('click', () => {
                    const targetId = btn.getAttribute('data-tab-target');
                    if (!targetId) return;
                    tabButtons.forEach((b) => b.classList.remove('active'));
                    tabPanels.forEach((panel) => panel.classList.remove('active'));
                    btn.classList.add('active');
                    const targetPanel = document.getElementById(targetId);
                    if (targetPanel) {
                        targetPanel.classList.add('active');
                    }
                });
            });
        }

        // Add custom functions to math.js
        math.import({
            square: function(x) { return x * x; },
            // Reciprocal trig
            sec: function(x) { return 1 / Math.cos(x); },
            csc: function(x) { return 1 / Math.sin(x); },
            cot: function(x) { return 1 / Math.tan(x); },
            // Inverse reciprocal trig (principal values)
            asec: function(x) { return Math.acos(1 / x); },
            acsc: function(x) { return Math.asin(1 / x); },
            acot: function(x) { return Math.atan(1 / x); }
        }, { override: true });

        // r-prefix UI helpers
        function renderRPrefix() {
            const sup = document.getElementById('rExp');
            if (!sup) return;
            if (!isFinite(uiRExponent) || Math.abs(uiRExponent - 1) < 1e-12) {
                sup.style.display = 'none';
            } else {
                sup.style.display = '';
                sup.textContent = String(uiRExponent);
            }
        }

        function startRExponentEdit() {
            const sup = document.getElementById('rExp');
            if (!sup) return;
            sup.style.display = '';
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'r-exp-input';
            input.value = String(uiRExponent);
            sup.textContent = '';
            sup.appendChild(input);
            input.focus();
            input.select();
            const finish = (apply) => {
                if (apply) {
                    let v = parseFloat(input.value);
                    if (!isFinite(v) || v === 0) v = 1;
                    uiRExponent = v;
                }
                renderRPrefix();
                // Trigger re-evaluation
                if (equationInput.value) {
                    const eq = equationInput.value.trim();
                    if (eq) {
                        autoSetRange(eq);
                    }
                    updateSliderBounds();
                    plotGraph();
                }
            };
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); finish(true); }
                else if (e.key === 'Escape') { e.preventDefault(); finish(false); }
            });
            input.addEventListener('blur', () => finish(true));
        }

        function initRPrefix() {
            const prefix = document.getElementById('rPrefix');
            if (!prefix) return;
            // Single click to open menu per request
            prefix.addEventListener('click', openRExponentMenu);
            renderRPrefix();
        }

        // Simple popup to pick r, rÂ², rÂ³ on double-click
        let rExpMenuEl = null;
        let rExpOutsideHandler = null;
        let rExpKeyHandler = null;
        function closeRExponentMenu() {
            if (rExpMenuEl && rExpMenuEl.parentNode) {
                rExpMenuEl.parentNode.removeChild(rExpMenuEl);
            }
            rExpMenuEl = null;
            if (rExpOutsideHandler) {
                document.removeEventListener('mousedown', rExpOutsideHandler, true);
                rExpOutsideHandler = null;
            }
            if (rExpKeyHandler) {
                document.removeEventListener('keydown', rExpKeyHandler, true);
                rExpKeyHandler = null;
            }
        }
        function openRExponentMenu() {
            closeRExponentMenu();
            const anchor = document.getElementById('rPrefix');
            if (!anchor) return;
            const menu = document.createElement('div');
            menu.className = 'r-exp-menu';
            const options = [
                { exp: 1, label: 'r' },
                { exp: 2, label: 'rÂ²' },
                { exp: 3, label: 'rÂ³' }
            ];
            options.forEach(opt => {
                const item = document.createElement('div');
                item.className = 'r-exp-option';
                item.textContent = opt.label;
                item.addEventListener('click', () => {
                    uiRExponent = opt.exp;
                    renderRPrefix();
                    closeRExponentMenu();
                    const eq = equationInput.value.trim();
                    if (eq) {
                        autoSetRange(eq);
                    }
                    updateSliderBounds();
                    plotGraph();
                });
                menu.appendChild(item);
            });
            document.body.appendChild(menu);
            const rect = anchor.getBoundingClientRect();
            menu.style.left = `${rect.left + window.scrollX}px`;
            menu.style.top = `${rect.bottom + window.scrollY + 6}px`;
            rExpMenuEl = menu;
            rExpOutsideHandler = (e) => {
                if (!rExpMenuEl) return;
                if (e.target === rExpMenuEl || rExpMenuEl.contains(e.target)) return;
                if (e.target === anchor || anchor.contains(e.target)) return;
                closeRExponentMenu();
            };
            rExpKeyHandler = (e) => {
                if (e.key === 'Escape') closeRExponentMenu();
            };
            document.addEventListener('mousedown', rExpOutsideHandler, true);
            document.addEventListener('keydown', rExpKeyHandler, true);
        }

        // Set canvas dimensions
        function setupCanvas(canvas) {
            const parent = canvas.parentElement;
            const parentRect = parent ? parent.getBoundingClientRect() : null;
            let size = parentRect?.width || parent?.clientWidth || parent?.offsetWidth || 0;

            // Fallback to the graphs container width if parent has no width yet
            if (!size) {
                const graphs = document.querySelector('.graphs-container');
                const graphsRect = graphs ? graphs.getBoundingClientRect() : null;
                size = graphsRect?.width || graphs?.clientWidth || graphs?.offsetWidth || 0;
            }

            // Final fallback to the canvas itself
            if (!size) {
                const rect = canvas.getBoundingClientRect();
                size = rect.width || rect.height || 0;
            }

            if (!size || !isFinite(size)) size = 480;

            size = Math.round(size);
            canvas.width = size;
            canvas.height = size;
        }

        setupCanvas(cartesianCanvas);
        setupCanvas(polarCanvas);

        // Handle window resize
        window.addEventListener('resize', () => {
            setupCanvas(cartesianCanvas);
            setupCanvas(polarCanvas);
            if (equationInput.value) {
                plotGraph();
            }
            positionEquationOverlay();
        });

        // Real-time updates with debouncing
        let updateTimeout;
        equationInput.addEventListener('input', () => {
            // If the change did not come from param sliders, infer params from the typed equation
            if (!updatingEquationFromSliders) {
                // While actively editing, do NOT auto-canonicalize shifts/equation text.
                // Canonicalization happens only when the user presses Enter to finalize.
                syncParamsFromEquationInput({ expandBounds: true, simplifyShifts: false });
            }
            // Update pretty preview immediately
            updateEquationPretty();
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                // Auto-detect periodicity and set range
                const equation = equationInput.value.trim();
                if (equation) {
                    autoSetRange(equation);
                }
                updateSliderBounds();
                plotGraph();
            }, 300); // 300ms delay
        });

        // Finalize equation edits (Enter) to canonicalize/simplify the displayed equation text.
        equationInput.addEventListener('keydown', (e) => {
            if (e.key !== 'Enter') return;
            e.preventDefault();
            if (updatingEquationFromSliders) return;
            try {
                // Re-infer params but allow shift simplification now that the user is finalizing.
                syncParamsFromEquationInput({ expandBounds: true, simplifyShifts: true });
                if (sliderSessionActive) {
                    updatingEquationFromSliders = true;
                    applyEditParams(); // rewrites equationInput.value into canonical base+params form
                    updatingEquationFromSliders = false;
                }

                // Also reformat trig arguments in whatever the user typed, even if it doesn't map cleanly
                // to the slider/base+params model (e.g., sin(2Î¸ - pi/3) -> sin(2(Î¸ - pi/6))).
                try {
                    const eqFull = (equationInput.value || '').trim();
                    if (eqFull) {
                        const before = equationInput.value || '';
                        const parts = extractRExponentAndRHS(eqFull);
                        const rhsRaw = (parts && parts.rhs) ? parts.rhs : eqFull;
                        // Normalize for mathjs parsing:
                        // - Î¸ -> theta
                        // - add implicit multiplication so "4Î¸" becomes "4*theta"
                        const rhsNorm = addImplicitMultiplication(normalizeThetaSymbols(rhsRaw));
                        let node = math.parse(rhsNorm);
                        node = factorLinearThetaInTrigArgsForDisplay(node);
                        node = reorderThetaMultiplicationForDisplay(node);
                        let out = stringifyWithDivisionParentheses(node);
                        out = denormalizeThetaSymbols(out);
                        out = makeImplicitMultiplicationDisplay(out);
                        out = normalizePlusMinusDisplay(out);
                        out = displayifyPiInEquation(out);
                        if (out && typeof out === 'string' && out !== equationInput.value) {
                            updatingEquationFromSliders = true;
                            equationInput.value = out;
                            updatingEquationFromSliders = false;
                            updateEquationPretty();
                            if (typeof updateEquationOverlay === 'function') updateEquationOverlay();
                        }

                        // If mathjs-based factoring didn't change anything (or didn't run), apply a simple
                        // regex-based fallback so cases like "sin(4Î¸ - 2)" still become "sin(4(Î¸ - 0.5))".
                        const fallback = rewriteSimplePhaseShiftInTrigTextForDisplay(equationInput.value || '');
                        if (fallback && typeof fallback === 'string' && fallback !== (equationInput.value || '')) {
                            updatingEquationFromSliders = true;
                            equationInput.value = fallback;
                            updatingEquationFromSliders = false;
                            updateEquationPretty();
                            if (typeof updateEquationOverlay === 'function') updateEquationOverlay();
                        } else if ((equationInput.value || '') === before) {
                            // Even if mathjs produced an equivalent-but-identical string, still try fallback on original.
                            const fb2 = rewriteSimplePhaseShiftInTrigTextForDisplay(before);
                            if (fb2 && typeof fb2 === 'string' && fb2 !== before) {
                                updatingEquationFromSliders = true;
                                equationInput.value = fb2;
                                updatingEquationFromSliders = false;
                                updateEquationPretty();
                                if (typeof updateEquationOverlay === 'function') updateEquationOverlay();
                            }
                        }
                    }
                } catch (_) {}

                // Finalize step: whatever the equation box currently contains is the source of truth.
                // Re-sync sliders (especially frequency + x-shift) from the finalized equation text.
                try {
                    syncParamsFromEquationInput({ expandBounds: true, simplifyShifts: true });
                    updateParamLabels();
                } catch (_) {}

                // Keep visuals consistent with the finalized equation text (Enter does not fire an input event).
                try {
                    const equation = (equationInput.value || '').trim();
                    if (equation) autoSetRange(equation);
                    updateSliderBounds();
                    plotGraph();
                } catch (_) {}
            } catch (_) {
                // no-op
            }
            try { equationInput.blur(); } catch (_) {}
        });

        // Mouse wheel zoom for cartesian
        cartesianCanvas.addEventListener('wheel', (e) => {
            if (interactionMode !== 'perspective') return;
            e.preventDefault();
            const rect = cartesianCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const padding = 60;
            const plotWidth = cartesianCanvas.width - 2 * padding;
            const plotHeight = cartesianCanvas.height - 2 * padding;
            
            const baseRange = 10 / cartesianZoom;
            const xMin = cartesianCenterX - baseRange;
            const xMax = cartesianCenterX + baseRange;
            const yMin = cartesianCenterY - baseRange;
            const yMax = cartesianCenterY + baseRange;
            
            // Convert mouse position to graph coordinates (point to keep fixed)
            const graphX = xMin + ((mouseX - padding) / plotWidth) * (xMax - xMin);
            const graphY = yMax - ((mouseY - padding) / plotHeight) * (yMax - yMin);
            
            // Make scroll direction feel natural: scroll up -> zoom in, scroll down -> zoom out
            const factor = e.deltaY > 0 ? 1.1 : 0.9;
            const oldZoom = cartesianZoom;
            cartesianZoom *= factor;
            
            // Adjust center so the point under mouse stays fixed
            const newRange = 10 / cartesianZoom;
            const oldRange = 10 / oldZoom;
            cartesianCenterX = graphX - ((mouseX - padding) / plotWidth - 0.5) * 2 * newRange;
            cartesianCenterY = graphY + ((mouseY - padding) / plotHeight - 0.5) * 2 * newRange;
            
            plotGraph();
        });

        // Click and drag panning for cartesian
        cartesianCanvas.addEventListener('mousedown', (e) => {
            if (interactionMode === 'perspective') {
            isDragging = true;
            cartesianCanvas.classList.add('dragging');
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            } else if (interactionMode === 'edit') {
                if (editAdjustMode === 'shift') {
                    // Begin translation (single click & hold) - only in shift mode
                    if (e.detail !== 2) {
                        const c = cartesianMouseToWorld(e);
                        if (c) {
                            isEditTranslating = true;
                            editStart = {
                                theta0: c.theta,
                                r0: c.r,
                                thetaShift: editParams.thetaShift,
                                rShift: editParams.rShift
                            };
                        }
                        e.preventDefault();
                    }
                } else if (editAdjustMode === 'amplitude') {
                    // Begin amplitude adjustment - lock to vertical movement
                    if (e.detail !== 2) {
                        isEditAdjustingAmplitude = true;
                        editStart = {
                            mouseY: e.clientY,
                            amplitude: editParams.amplitude
                        };
                        e.preventDefault();
                    }
                } else if (editAdjustMode === 'frequency') {
                    // Begin frequency adjustment - lock to horizontal movement
                    if (e.detail !== 2) {
                        isEditAdjustingFrequency = true;
                        editStart = {
                            mouseX: e.clientX,
                            frequency: editParams.frequency
                        };
                        e.preventDefault();
                    }
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (interactionMode === 'perspective' && isDragging) {
                const rect = cartesianCanvas.getBoundingClientRect();
                const padding = 60;
                const plotWidth = cartesianCanvas.width - 2 * padding;
                const plotHeight = cartesianCanvas.height - 2 * padding;
                
                const baseRange = 10 / cartesianZoom;
                const xRange = 2 * baseRange;
                const yRange = 2 * baseRange;
                
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                // Convert pixel movement to graph coordinate movement
                const dx = -(deltaX / plotWidth) * xRange;
                const dy = (deltaY / plotHeight) * yRange;
                
                cartesianCenterX += dx;
                cartesianCenterY += dy; // drag down -> content down (invert Y panning direction)
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                plotGraph();
            } else if (interactionMode === 'edit') {
                if (editAdjustMode === 'shift' && isEditTranslating && editStart) {
                    const c = cartesianMouseToWorld(e);
                    if (c) {
                        const dTheta = c.theta - editStart.theta0;
                        const dR = c.r - editStart.r0;
                        editParams.thetaShift = snapToIncrement(editStart.thetaShift + dTheta, 0.01);
                        editParams.rShift = snapToIncrement(editStart.rShift + dR, 0.01);
                        applyEditParams();
                    }
                } else if (editAdjustMode === 'amplitude' && isEditAdjustingAmplitude && editStart) {
                    // Lock to vertical movement only - calculate amplitude change from Y movement
                    const deltaY = e.clientY - editStart.mouseY;
                    // Convert pixel movement to amplitude change
                    // Negative deltaY (moving up) increases amplitude, positive (moving down) decreases
                    // Scale factor: ~0.02 per pixel for increased sensitivity
                    const amplitudeDelta = -deltaY * 0.02;
                    const newAmplitude = editStart.amplitude + amplitudeDelta;
                    // Allow negative amplitude
                    editParams.amplitude = snapToIncrement(newAmplitude, 0.01);
                    applyEditParams();
                    // Lock mouse to vertical movement by preventing default and constraining
                    e.preventDefault();
                } else if (editAdjustMode === 'frequency' && isEditAdjustingFrequency && editStart) {
                    // Lock to horizontal movement only - calculate frequency change from X movement
                    const deltaX = e.clientX - editStart.mouseX;
                    // Convert pixel movement to frequency change
                    // Positive deltaX (moving right) increases frequency, negative (moving left) decreases
                    // Scale factor: ~0.02 per pixel for increased sensitivity
                    const frequencyDelta = deltaX * 0.02;
                    const newFrequency = editStart.frequency + frequencyDelta;
                    // Clamp frequency to reasonable bounds (0.05 to 20)
                    const clamped = Math.max(0.05, Math.min(20, newFrequency));
                    editParams.frequency = Math.max(0.05, Math.min(20, snapToIncrement(clamped, 0.01)));
                    applyEditParams();
                    // Lock mouse to horizontal movement by preventing default
                    e.preventDefault();
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                cartesianCanvas.classList.remove('dragging');
            }
            if (isEditTranslating) {
                isEditTranslating = false;
            }
            if (isEditAdjustingAmplitude) {
                isEditAdjustingAmplitude = false;
            }
            if (isEditAdjustingFrequency) {
                isEditAdjustingFrequency = false;
            }
        });

        function resetZoomCartesian() {
            if (defaultCartesianBounds) {
                setViewFromRange(
                    defaultCartesianBounds.xMin,
                    defaultCartesianBounds.xMax,
                    defaultCartesianBounds.yMin,
                    defaultCartesianBounds.yMax
                );
                updateRangeInputsFromView();
            } else {
                cartesianZoom = 1.0;
                cartesianCenterX = 0;
                cartesianCenterY = 0;
                plotGraph();
                updateRangeInputsFromView();
            }
        }

        // Mouse wheel zoom for polar
        polarCanvas.addEventListener('wheel', (e) => {
            if (interactionMode !== 'perspective') return;
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            polarZoom *= factor;
            plotGraph();
        });

        function resetZoomPolar() {
            polarZoom = (defaultPolarZoom !== null) ? defaultPolarZoom : 1.0;
            plotGraph();
        }

        function resetBothGraphs() {
            resetZoomCartesian();
            resetZoomPolar();
        }

        function insertSymbol(symbol) {
            const input = equationInput;
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const text = input.value;
            const before = text.substring(0, start);
            const after = text.substring(end);
            
            input.value = before + symbol + after;
            input.selectionStart = input.selectionEnd = start + symbol.length;
            input.focus();
            
            // Trigger input event to update graph
            input.dispatchEvent(new Event('input'));
        }

        // Keyboard shortcuts for the equation box:
        // - typing "sqrt" expands to "âˆš()" with caret inside
        // - typing "abs" expands to "||" with caret inside
        // - typing "|" auto-pairs as "||" (or wraps selection)
        (function setupEquationShortcuts() {
            const input = document.getElementById('equation');
            if (!input) return;
            let inShortcutEdit = false;

            function replaceSelection(el, replacement, caretIndex) {
                const start = el.selectionStart ?? 0;
                const end = el.selectionEnd ?? start;
                const text = el.value || '';
                el.value = text.slice(0, start) + replacement + text.slice(end);
                const caret = (typeof caretIndex === 'number') ? caretIndex : (start + replacement.length);
                el.selectionStart = el.selectionEnd = Math.max(0, Math.min(el.value.length, caret));
            }

            function getWordBeforeCaret(el) {
                const pos = el.selectionStart ?? 0;
                const text = el.value || '';
                let i = pos - 1;
                while (i >= 0 && /[A-Za-z]/.test(text[i])) i--;
                const start = i + 1;
                const word = text.slice(start, pos);
                const prev = start > 0 ? text[start - 1] : '';
                const next = pos < text.length ? text[pos] : '';
                return { word, start, end: pos, prev, next };
            }

            function expandKeywordIfNeeded(el, reason) {
                if (inShortcutEdit) return;
                if ((el.selectionStart ?? 0) !== (el.selectionEnd ?? 0)) return; // only when caret is collapsed
                const { word, start, end, prev, next } = getWordBeforeCaret(el);
                if (!word) return;
                // Only expand on token boundaries (avoid e.g. "sqrtn" or "fabs")
                if (/[A-Za-z]/.test(prev) || /[A-Za-z]/.test(next)) return;

                const lower = word.toLowerCase();
                if (lower !== 'sqrt' && lower !== 'abs') return;

                inShortcutEdit = true;
                try {
                    // Replace the word range explicitly
                    const text = el.value || '';
                    const before = text.slice(0, start);
                    const after = text.slice(end);
                    if (lower === 'sqrt') {
                        el.value = before + 'âˆš()' + after;
                        // caret inside parentheses: âˆš( | )
                        const caret = before.length + 2;
                        el.selectionStart = el.selectionEnd = caret;
                    } else if (lower === 'abs') {
                        el.value = before + '||' + after;
                        // caret inside bars: | | 
                        const caret = before.length + 1;
                        el.selectionStart = el.selectionEnd = caret;
                    }
                } finally {
                    inShortcutEdit = false;
                }
            }

            input.addEventListener('keydown', (e) => {
                if (e.defaultPrevented) return;
                if (e.ctrlKey || e.metaKey || e.altKey) return;

                // Auto-pair absolute bars, or wrap selection.
                if (e.key === '|') {
                    e.preventDefault();
                    inShortcutEdit = true;
                    try {
                        const start = input.selectionStart ?? 0;
                        const end = input.selectionEnd ?? start;
                        const text = input.value || '';
                        if (start !== end) {
                            const selected = text.slice(start, end);
                            input.value = text.slice(0, start) + '|' + selected + '|' + text.slice(end);
                            input.selectionStart = start + 1;
                            input.selectionEnd = end + 1;
                        } else {
                            // Insert paired bars and place caret in the middle
                            input.value = text.slice(0, start) + '||' + text.slice(end);
                            input.selectionStart = input.selectionEnd = start + 1;
                        }
                    } finally {
                        inShortcutEdit = false;
                    }
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                    return;
                }

                // If the user types "(" immediately after "sqrt", expand into âˆš() and keep caret inside.
                if (e.key === '(') {
                    const { word } = getWordBeforeCaret(input);
                    if ((word || '').toLowerCase() === 'sqrt') {
                        e.preventDefault();
                        expandKeywordIfNeeded(input, 'paren');
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        return;
                    }
                }
            });

            input.addEventListener('input', () => {
                // Expand immediately after finishing the token (e.g., after typing the last letter).
                expandKeywordIfNeeded(input, 'input');
            }, true);
        })();

        // Detect periodicity and calculate appropriate range
        function detectPeriodicity(equation) {
            // Expect equation to already be preprocessed
            const processed = preprocessEquation(equation);
            // Try to detect coefficients inside trig functions, e.g., sin(3*theta) => period 2Ï€/3
            const trigRegex = /\b(sin|cos|tan)\s*\(([^()]*)\)/g;
            const sinCosCoeffs = [];
            const tanCoeffs = [];
            
            function evalSafeNumeric(expr) {
                try {
                    const val = math.evaluate(expr);
                    const num = typeof val === 'object' && val && val.re !== undefined ? val.re : val;
                    return (typeof num === 'number' && isFinite(num)) ? num : null;
                } catch (_) {
                    return null;
                }
            }
            
            function parseThetaCoefficient(arg) {
                if (!arg || !/\btheta\b/.test(arg)) return null;
                let s = addImplicitMultiplication(arg).replace(/\s+/g, '');
                
                // Parentheses wrapper strip (balanced, simple check)
                const startsWithParen = s.startsWith('(');
                const endsWithParen = s.endsWith(')');
                if (startsWithParen && endsWithParen) {
                    let bal = 0;
                    let balanced = true;
                    for (let i = 0; i < s.length; i++) {
                        if (s[i] === '(') bal++;
                        else if (s[i] === ')') bal--;
                        if (bal < 0) { balanced = false; break; }
                        if (i < s.length - 1 && bal === 0) balanced = false;
                    }
                    if (balanced) {
                        s = s.slice(1, -1);
                    }
                }
                
                // Patterns:
                // a*theta + c
                let m = s.match(/^([+\-]?(?:\d+(?:\.\d+)?|\.\d+|(?:\d+(?:\.\d+)?|\.\d+)?(?:\*|\/)?pi))\*theta(?:[+\-].*)?$/i);
                if (m) {
                    const num = evalSafeNumeric(m[1].replace(/pi/gi, 'pi'));
                    if (num !== null) return num;
                }
                // theta*a + c
                m = s.match(/^theta\*([+\-]?(?:\d+(?:\.\d+)?|\.\d+|(?:\d+(?:\.\d+)?|\.\d+)?(?:\*|\/)?pi))(?:[+\-].*)?$/i);
                if (m) {
                    const num = evalSafeNumeric(m[1].replace(/pi/gi, 'pi'));
                    if (num !== null) return num;
                }
                // theta/ a
                m = s.match(/^theta\/([+\-]?(?:\d+(?:\.\d+)?|\.\d+|(?:\d+(?:\.\d+)?|\.\d+)?(?:\*|\/)?pi))(?:[+\-].*)?$/i);
                if (m) {
                    const num = evalSafeNumeric(m[1].replace(/pi/gi, 'pi'));
                    if (num !== null && Math.abs(num) > 1e-12) return 1 / num;
                }
                // +/- theta (+ c)
                m = s.match(/^[+\-]?theta(?:[+\-].*)?$/i);
                if (m) {
                    return s.startsWith('-') ? -1 : 1;
                }
                
                // Fallback: try to approximate linear coefficient numerically on linear forms
                try {
                    const f = (t) => {
                        const expr = s.replace(/\btheta\b/g, `(${t})`).replace(/pi/gi, 'pi');
                        return evalSafeNumeric(expr);
                    };
                    const t1 = 0.0, t2 = 1.0, t3 = 2.0;
                    const y1 = f(t1), y2 = f(t2), y3 = f(t3);
                    if ([y1, y2, y3].every(v => typeof v === 'number' && isFinite(v))) {
                        const slope1 = y2 - y1;
                        const slope2 = y3 - y2;
                        // If slopes are roughly equal, assume linear and return slope
                        if (Math.abs(slope1 - slope2) < 1e-6) {
                            return slope1;
                        }
                    }
                } catch (_) {}
                
                return null;
            }
            
            let m;
            while ((m = trigRegex.exec(processed)) !== null) {
                const fn = m[1];
                const arg = m[2];
                const coeff = parseThetaCoefficient(arg);
                if (coeff === null || !isFinite(coeff) || Math.abs(coeff) < 1e-12) continue;
                if (fn === 'tan') tanCoeffs.push(Math.abs(coeff));
                else sinCosCoeffs.push(Math.abs(coeff));
            }
            
            const hasSinCos = sinCosCoeffs.length > 0;
            const hasTan = tanCoeffs.length > 0;
            if (!hasSinCos && !hasTan) {
                // No trig or no recognizable linear theta inside args
                const anySinCos = /\b(sin|cos)\b/.test(processed);
                const anyTan = /\btan\b/.test(processed);
                if (anySinCos) return { period: 2 * Math.PI, periods: 1 };
                if (anyTan) return { period: Math.PI, periods: 1 };
                return null;
            }
            
            function gcdInt(a, b) {
                a = Math.abs(a); b = Math.abs(b);
                while (b) { const t = a % b; a = b; b = t; }
                return a;
            }
            
            function gcdOfArray(arr) {
                if (arr.length === 0) return 0;
                let g = Math.round(arr[0]);
                for (let i = 1; i < arr.length; i++) {
                    g = gcdInt(g, Math.round(arr[i]));
                }
                return g;
            }
            
            // Use integer gcd when all coefficients are integers; else default to base period
            let sinCosPeriod = null;
            if (hasSinCos) {
                const allInt = sinCosCoeffs.every(c => Math.abs(c - Math.round(c)) < 1e-9);
                if (allInt) {
                    const g = gcdOfArray(sinCosCoeffs);
                    sinCosPeriod = (g > 0) ? (2 * Math.PI) / g : 2 * Math.PI;
                } else {
                    // Single term case: use its coefficient to scale
                    if (sinCosCoeffs.length === 1) {
                        sinCosPeriod = (2 * Math.PI) / sinCosCoeffs[0];
                    } else {
                        sinCosPeriod = 2 * Math.PI;
                    }
                }
            }
            
            let tanPeriod = null;
            if (hasTan) {
                const allInt = tanCoeffs.every(c => Math.abs(c - Math.round(c)) < 1e-9);
                if (allInt) {
                    const g = gcdOfArray(tanCoeffs);
                    tanPeriod = (g > 0) ? (Math.PI) / g : Math.PI;
                } else {
                    if (tanCoeffs.length === 1) {
                        tanPeriod = (Math.PI) / tanCoeffs[0];
                    } else {
                        tanPeriod = Math.PI;
                    }
                }
            }
            
            // If both appear, choose a safe common period (fallback to 2Ï€)
            if (sinCosPeriod !== null && tanPeriod !== null) {
                // Return a common multiple; conservative choice is 2Ï€
                return { period: 2 * Math.PI, periods: 1 };
            }
            if (sinCosPeriod !== null) return { period: sinCosPeriod, periods: 1 };
            if (tanPeriod !== null) return { period: tanPeriod, periods: 1 };
            return null;
        }

        // ===== Typed-equation shift detection (for Shifts toggle) =====
        // Detect phase shift inside trig args like sin(a*theta + c) -> thetaShift = -c/a
        function evalSafeNumericGlobal(expr) {
            try {
                const val = math.evaluate(expr);
                const num = (typeof val === 'object' && val && val.re !== undefined) ? val.re : val;
                return (typeof num === 'number' && isFinite(num)) ? num : null;
            } catch (_) {
                return null;
            }
        }

        function parseLinearThetaAC(arg) {
            if (!arg || !/\btheta\b/.test(arg)) return null;
            let s = addImplicitMultiplication(arg).replace(/\s+/g, '');

            // Strip one balanced outer paren layer
            if (s.startsWith('(') && s.endsWith(')')) {
                let bal = 0;
                let balanced = true;
                for (let i = 0; i < s.length; i++) {
                    if (s[i] === '(') bal++;
                    else if (s[i] === ')') bal--;
                    if (bal < 0) { balanced = false; break; }
                    if (i < s.length - 1 && bal === 0) balanced = false;
                }
                if (balanced) s = s.slice(1, -1);
            }

            const numExpr = (x) => (x || '').replace(/pi/gi, 'pi');
            const parseConst = (cStr) => {
                if (!cStr) return 0;
                const v = evalSafeNumericGlobal(numExpr(cStr));
                return (v !== null ? v : 0);
            };

            // a*theta + c
            let m = s.match(/^([+\-]?(?:\d+(?:\.\d+)?|\.\d+|(?:\d+(?:\.\d+)?|\.\d+)?(?:\*|\/)?pi))\*theta([+\-].+)?$/i);
            if (m) {
                const a = evalSafeNumericGlobal(numExpr(m[1]));
                if (a !== null) return { a, c: parseConst(m[2]) };
            }
            // theta*a + c
            m = s.match(/^theta\*([+\-]?(?:\d+(?:\.\d+)?|\.\d+|(?:\d+(?:\.\d+)?|\.\d+)?(?:\*|\/)?pi))([+\-].+)?$/i);
            if (m) {
                const a = evalSafeNumericGlobal(numExpr(m[1]));
                if (a !== null) return { a, c: parseConst(m[2]) };
            }
            // theta/a + c
            m = s.match(/^theta\/([+\-]?(?:\d+(?:\.\d+)?|\.\d+|(?:\d+(?:\.\d+)?|\.\d+)?(?:\*|\/)?pi))([+\-].+)?$/i);
            if (m) {
                const denom = evalSafeNumericGlobal(numExpr(m[1]));
                if (denom !== null && Math.abs(denom) > 1e-12) return { a: 1 / denom, c: parseConst(m[2]) };
            }
            // +/-theta + c
            m = s.match(/^([+\-]?)theta([+\-].+)?$/i);
            if (m) {
                const a = (m[1] === '-') ? -1 : 1;
                return { a, c: parseConst(m[2]) };
            }

            // Fallback: numeric linear fit if expression is linear in theta
            try {
                const f = (t) => {
                    const expr = s.replace(/\btheta\b/g, `(${t})`).replace(/pi/gi, 'pi');
                    return evalSafeNumericGlobal(expr);
                };
                const y0 = f(0.0), y1 = f(1.0), y2 = f(2.0);
                if ([y0, y1, y2].every(v => typeof v === 'number' && isFinite(v))) {
                    const slope1 = y1 - y0;
                    const slope2 = y2 - y1;
                    if (Math.abs(slope1 - slope2) < 1e-6) {
                        return { a: slope1, c: y0 };
                    }
                }
            } catch (_) {}

            return null;
        }

        function detectThetaShiftFromEquation(equation) {
            try {
                const eq = (equation || '').trim();
                if (!eq) return null;
                const { rhs } = extractRExponentAndRHS(eq);
                const processedRhs = preprocessEquation(rhs || eq);

                // Take the first trig arg we can see (covers common cases like sin(theta - pi/4))
                const trigRegex = /\b(sin|cos|tan)\s*\(([^()]*)\)/i;
                const m = processedRhs.match(trigRegex);
                if (!m) return null;
                const arg = m[2] || '';
                const ac = parseLinearThetaAC(arg);
                if (!ac || !isFinite(ac.a) || Math.abs(ac.a) < 1e-12) return null;
                const shift = -ac.c / ac.a;
                return (isFinite(shift) ? shift : null);
            } catch (_) {
                return null;
            }
        }

        // Compute current view bounds (ignores manual fields; view is driven by zoom/center)
        function getViewBounds() {
            const baseRange = 10 / cartesianZoom;
            return {
                xMin: cartesianCenterX - baseRange,
                xMax: cartesianCenterX + baseRange,
                yMin: cartesianCenterY - baseRange,
                yMax: cartesianCenterY + baseRange
            };
        }

        // Apply view from explicit bounds; keeps graph as the source of truth
        function setViewFromRange(xMin, xMax, yMin, yMax) {
            if ([xMin, xMax, yMin, yMax].some(v => typeof v !== 'number' || !isFinite(v))) {
                return;
            }
            const centerX = (xMin + xMax) / 2;
            const centerY = (yMin + yMax) / 2;
            const halfX = Math.abs(xMax - xMin) / 2;
            const halfY = Math.abs(yMax - yMin) / 2;
            const desiredBaseRange = Math.max(halfX, halfY, 0.0001);
            cartesianCenterX = centerX;
            cartesianCenterY = centerY;
            cartesianZoom = 10 / desiredBaseRange;
            // Clear any manual overrides; view is authoritative
            manualXMin = null;
            manualXMax = null;
            manualYMin = null;
            manualYMax = null;
            plotGraph();
        }

        // Keep range inputs in sync with current view unless the user is actively editing
        let isEditingRangeInput = false;
        function updateRangeInputsFromView() {
            const xMinInput = document.getElementById('xMin');
            const xMaxInput = document.getElementById('xMax');
            const yMinInput = document.getElementById('yMin');
            const yMaxInput = document.getElementById('yMax');
            if (!xMinInput || !xMaxInput || !yMinInput || !yMaxInput) return;
            if (isEditingRangeInput) return;
            const { xMin, xMax, yMin, yMax } = getViewBounds();
            xMinInput.value = xMin.toFixed(3);
            xMaxInput.value = xMax.toFixed(3);
            yMinInput.value = yMin.toFixed(3);
            yMaxInput.value = yMax.toFixed(3);
        }

        // Auto-set initial view range based on periodicity (non-intrusive; does not show UI)
        function autoSetRange(equation) {
            if (!equation || !equation.trim()) return;
            try {
                const processed = preprocessEquation(equation);
                const periodicity = detectPeriodicity(processed);
                if (!periodicity) return;
                const { period } = periodicity;
                const thetaMin = 0;
                const thetaMax = period;

                // Sample r over theta range to estimate y bounds
                const sampleStep = 0.02;
                let minR = Infinity;
                let maxR = -Infinity;
                const { exponent: effExp, rhs: evalExpr } = extractRExponentAndRHS(equation);
                for (let theta = thetaMin; theta <= thetaMax; theta += sampleStep) {
                    try {
                        const expr = evalExpr.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        let rBase = math.evaluate(expr);
                        if (typeof rBase === 'object' && rBase.re !== undefined) rBase = rBase.re;
                        let r = applyExponentToValue(rBase, effExp);
                        if (typeof r === 'object' && r.re !== undefined) r = r.re;
                        if (!isNaN(r) && isFinite(r)) {
                            minR = Math.min(minR, r);
                            maxR = Math.max(maxR, r);
                        }
                    } catch (e) {}
                }
                if (!isFinite(minR) || !isFinite(maxR)) {
                    minR = -10;
                    maxR = 10;
                }
                const padding = Math.max((maxR - minR) * 0.1, 0.1);
                setViewFromRange(thetaMin, thetaMax, minR - padding, maxR + padding);
                updateRangeInputsFromView();
                rememberDefaultCartesianView(true);
            } catch (e) {
                // Silent fail
            }
        }

        function toggleRangeSection() {
            const section = document.getElementById('rangeSection');
            if (section.style.display === 'none') {
                section.style.display = 'block';
                // Pre-fill with current view values when opening
                updateRangeInputsFromView();
            } else {
                section.style.display = 'none';
            }
        }

        function resetRangeToAuto() {
            manualXMin = null;
            manualXMax = null;
            manualYMin = null;
            manualYMax = null;
            
            updateRangeInputsFromView();
            
            plotGraph();
        }

        // Add event listeners for range inputs (setup after DOM is ready)
        function setupRangeInputListeners() {
            const rangeInputs = ['xMin', 'xMax', 'yMin', 'yMax'];
            rangeInputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('focus', () => { isEditingRangeInput = true; });
                    input.addEventListener('blur', () => { isEditingRangeInput = false; });
                    let updateTimeout;
                    input.addEventListener('input', () => {
                        clearTimeout(updateTimeout);
                        updateTimeout = setTimeout(() => {
                            // Read all inputs and apply view
                            const bounds = getViewBounds();
                            const xMinInput = parseFloat(document.getElementById('xMin').value);
                            const xMaxInput = parseFloat(document.getElementById('xMax').value);
                            const yMinInput = parseFloat(document.getElementById('yMin').value);
                            const yMaxInput = parseFloat(document.getElementById('yMax').value);
                            const xMin = isNaN(xMinInput) ? bounds.xMin : xMinInput;
                            const xMax = isNaN(xMaxInput) ? bounds.xMax : xMaxInput;
                            const yMin = isNaN(yMinInput) ? bounds.yMin : yMinInput;
                            const yMax = isNaN(yMaxInput) ? bounds.yMax : yMaxInput;
                            setViewFromRange(xMin, xMax, yMin, yMax);
                            updateRangeInputsFromView();
                        }, 300);
                    });
                }
            });
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('show');
            setTimeout(() => {
                errorMessage.classList.remove('show');
            }, 5000);
        }

        // Pretty-print typed math in any textbox: 'pi'->'Ï€', 'theta'->'Î¸', 'sqrt('->'âˆš(', '^n'->superscripts
        (function setupPrettyPrinting() {
            const superscripts = { '0':'â°','1':'Â¹','2':'Â²','3':'Â³','4':'â´','5':'âµ','6':'â¶','7':'â·','8':'â¸','9':'â¹','+':'âº','-':'â»' };
            function toSuperscriptDigits(textDigits) {
                let out = '';
                for (const ch of textDigits) out += superscripts[ch] || ch;
                return out;
            }
            function toPrettyAscii(value) {
                // Ensure base ASCII is turned into pretty where helpful
                return value
                    .replace(/\bpi\b/gi, 'Ï€')
                    .replace(/\btheta\b/gi, 'Î¸')
                    .replace(/sqrt\s*\(/gi, 'âˆš(');
            }
            function transformWithCaret(value, caretIndex, regex, replacer) {
                if (!value) return { value, caretIndex };
                let result = '';
                let last = 0;
                let m;
                regex.lastIndex = 0;
                while ((m = regex.exec(value)) !== null) {
                    const before = value.slice(last, m.index);
                    const replacement = replacer(...m);
                    result += before + replacement;
                    if (m.index < caretIndex) {
                        const delta = m[0].length - replacement.length;
                        // Adjust caret only for the overlap before caret position
                        caretIndex -= Math.max(0, Math.min(delta, caretIndex - m.index));
                    }
                    last = regex.lastIndex;
                }
                result += value.slice(last);
                return { value: result, caretIndex };
            }
            function prettyPrintString(value, caret) {
                // pi -> Ï€
                ({ value, caretIndex: caret } = transformWithCaret(value, caret, /\bpi\b/gi, () => 'Ï€'));
                // theta -> Î¸
                ({ value, caretIndex: caret } = transformWithCaret(value, caret, /\btheta\b/gi, () => 'Î¸'));
                // sqrt( -> âˆš(
                ({ value, caretIndex: caret } = transformWithCaret(value, caret, /sqrt\s*\(/gi, () => 'âˆš('));
                // ^[+-]?\d+ -> superscripts
                ({ value, caretIndex: caret } = transformWithCaret(value, caret, /\^([+\-]?\d+)/g, (_m, digits) => toSuperscriptDigits(digits)));
                return { value, caret };
            }
            function isEligibleTextBox(el) {
                if (!el) return false;
                if (el.isContentEditable) return true;
                if (el.tagName === 'TEXTAREA') return true;
                if (el.tagName === 'INPUT') {
                    const type = (el.getAttribute('type') || 'text').toLowerCase();
                    return ['text','search','url','tel','email','password'].includes(type);
                }
                return false;
            }
            function applyPretty(el) {
                if (!isEligibleTextBox(el)) return;
                try {
                    const hasSel = typeof el.selectionStart === 'number' && typeof el.selectionEnd === 'number';
                    const caret = hasSel ? el.selectionStart : (el.value ? el.value.length : 0);
                    const { value, caret: newCaret } = prettyPrintString(el.value || '', caret);
                    if (value !== el.value) {
                        el.value = value;
                        if (hasSel) {
                            el.selectionStart = el.selectionEnd = Math.min(value.length, newCaret);
                        }
                        // Bubble input event so listeners (e.g., graph redraw) react to programmatic change
                        el.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                } catch (_) {}
            }
            document.addEventListener('input', (e) => {
                applyPretty(e.target);
            }, true);
            document.addEventListener('paste', (e) => {
                const t = e.target;
                setTimeout(() => applyPretty(t), 0);
            }, true);
            window.addEventListener('load', () => {
                document.querySelectorAll('input[type=\"text\"], textarea, [contenteditable=\"true\"]').forEach(applyPretty);
            });
        })();

        // Pretty fraction preview for the equation box
        function escapeHTML(s) {
            return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;');
        }
        function isWordChar(ch) {
            return /[A-Za-z0-9_Ï€Î¸]/.test(ch);
        }
        function isSuperChar(ch) {
            return /[â°Â¹Â²Â³â´âµâ¶â·â¸â¹âºâ»]/.test(ch);
        }
        function findMatchingLeftParen(s, pos) {
            let depth = 0;
            for (let i = pos; i >= 0; i--) {
                if (s[i] === ')') depth++;
                else if (s[i] === '(') {
                    depth--;
                    if (depth === 0) return i;
                }
            }
            return -1;
        }
        function findMatchingRightParen(s, pos) {
            let depth = 0;
            for (let i = pos; i < s.length; i++) {
                if (s[i] === '(') depth++;
                else if (s[i] === ')') {
                    depth--;
                    if (depth === 0) return i;
                }
            }
            return -1;
        }
        function grabNumeratorSpan(s, slashPos) {
            let i = slashPos - 1;
            while (i >= 0 && /\s/.test(s[i])) i--;
            if (i >= 0 && s[i] === ')') {
                let start = findMatchingLeftParen(s, i);
                if (start >= 0) {
                    // include function name or âˆš preceding the '('
                    let j = start - 1;
                    if (j >= 0 && s[j] === 'âˆš') {
                        start = j;
                    } else {
                        let k = j;
                        while (k >= 0 && /[A-Za-z]/.test(s[k])) k--;
                        if (k < j) start = k + 1;
                    }
                    return { start, end: i };
                }
            }
            // fallback: contiguous token (word/superscripts)
            let end = i;
            let start = i;
            while (start >= 0 && (isWordChar(s[start]) || isSuperChar(s[start]))) start--;
            start++;
            return { start, end };
        }
        function grabDenominatorSpan(s, slashPos) {
            let i = slashPos + 1;
            while (i < s.length && /\s/.test(s[i])) i++;
            if (i < s.length && s[i] === 'âˆš' && i + 1 < s.length && s[i + 1] === '(') {
                const end = findMatchingRightParen(s, i + 1);
                if (end >= 0) return { start: i, end };
            }
            if (i < s.length && s[i] === '(') {
                const end = findMatchingRightParen(s, i);
                if (end >= 0) return { start: i, end };
            }
            if (i < s.length && /[A-Za-z]/.test(s[i])) {
                let j = i;
                while (j < s.length && /[A-Za-z]/.test(s[j])) j++;
                if (j < s.length && s[j] === '(') {
                    const end = findMatchingRightParen(s, j);
                    if (end >= 0) return { start: i, end };
                }
            }
            let start = i;
            let end = i;
            while (end < s.length && (isWordChar(s[end]) || isSuperChar(s[end]))) end++;
            return { start, end: end - 1 };
        }
        function renderPrettyHTML(s) {
            if (!s) return '';
            // normalize some pretty forms
            s = s.replace(/\bpi\b/gi, 'Ï€').replace(/\btheta\b/gi, 'Î¸').replace(/sqrt\s*\(/gi, 'âˆš(');
            // superscripts for ^digits
            s = s.replace(/\^([+\-]?\d+)/g, (_m, digits) => {
                const map = { '0':'â°','1':'Â¹','2':'Â²','3':'Â³','4':'â´','5':'âµ','6':'â¶','7':'â·','8':'â¸','9':'â¹','+':'âº','-':'â»' };
                return Array.from(digits).map(ch => map[ch] || ch).join('');
            });
            // IMPORTANT: do not auto-render "a/b" as a stacked fraction.
            // Keep divisions as plain text so slider-driven updates don't turn values into fractions.
            return escapeHTML(s);
        }
        function updateEquationPretty() {
            const el = document.getElementById('equationPretty');
            if (!el || !equationInput) return;
            const raw = equationInput.value || '';
            el.innerHTML = renderPrettyHTML(raw);
            colorizeEquation(el);
            updateEquationOverlay(); // keep input overlay in sync
        }
        function colorizeEquation(container) {
            const thetaEl = document.getElementById('toggleTheta');
            const radiusEl = document.getElementById('toggleRadius');
            const colorRadiusEl = document.getElementById('toggleColorRadius');
            const colorThetaOn = !!(thetaEl && thetaEl.checked);
            const colorROn = !!((radiusEl && radiusEl.checked) || (colorRadiusEl && colorRadiusEl.checked));
            if (!colorThetaOn && !colorROn) return;

            function wrapMatchesInTextNode(node, token, className) {
                const text = node.nodeValue || '';
                const parts = [];
                let i = 0;
                while (i < text.length) {
                    if (token === 'theta') {
                        const idx = text.indexOf('theta', i);
                        if (idx === -1) break;
                        if (idx > i) parts.push(document.createTextNode(text.slice(i, idx)));
                        const span = document.createElement('span');
                        span.className = className;
                        span.textContent = 'theta';
                        parts.push(span);
                        i = idx + 5;
                        continue;
                    } else if (token === 'Î¸') {
                        const idx = text.indexOf('Î¸', i);
                        if (idx === -1) break;
                        if (idx > i) parts.push(document.createTextNode(text.slice(i, idx)));
                        const span = document.createElement('span');
                        span.className = className;
                        span.textContent = 'Î¸';
                        parts.push(span);
                        i = idx + 1;
                        continue;
                    } else if (token === 'r') {
                        let found = -1;
                        for (let j = i; j < text.length; j++) {
                            if (text[j] === 'r') {
                                const prev = j > 0 ? text[j - 1] : '';
                                const next = j < text.length - 1 ? text[j + 1] : '';
                                if (!/[A-Za-z0-9]/.test(prev) && !/[A-Za-z0-9]/.test(next)) { found = j; break; }
                            }
                        }
                        if (found === -1) break;
                        if (found > i) parts.push(document.createTextNode(text.slice(i, found)));
                        const span = document.createElement('span');
                        span.className = className;
                        span.textContent = 'r';
                        parts.push(span);
                        i = found + 1;
                        continue;
                    } else {
                        break;
                    }
                }
                if (parts.length === 0) return;
                if (i < text.length) parts.push(document.createTextNode(text.slice(i)));
                const parent = node.parentNode;
                parts.forEach(n => parent.insertBefore(n, node));
                parent.removeChild(node);
            }

            // First pass: wrap ascii 'theta'
            const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
            const textNodes = [];
            while (true) {
                const n = walker.nextNode();
                if (!n) break;
                if (n.nodeValue) textNodes.push(n);
            }
            if (colorThetaOn) {
                textNodes.forEach(node => wrapMatchesInTextNode(node, 'theta', 'token-theta'));
            }
            // Second pass: new walk for 'Î¸' and 'r'
            const walker2 = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
            const nodes2 = [];
            while (true) {
                const n = walker2.nextNode();
                if (!n) break;
                if (n.nodeValue) nodes2.push(n);
            }
            nodes2.forEach(node => {
                if (colorThetaOn) wrapMatchesInTextNode(node, 'Î¸', 'token-theta');
                if (colorROn) wrapMatchesInTextNode(node, 'r', 'token-r');
            });
        }
        function ensureEquationOverlay() {
            let overlay = document.getElementById('equationOverlay');
            if (!overlay) {
                const field = document.querySelector('.equation-field');
                if (!field) return null;
                overlay = document.createElement('div');
                overlay.id = 'equationOverlay';
                overlay.className = 'equation-color-overlay';
                overlay.setAttribute('aria-hidden', 'true');
                field.appendChild(overlay);
            }
            return overlay;
        }
        function positionEquationOverlay() {
            const field = document.querySelector('.equation-field');
            const input = document.getElementById('equation');
            const overlay = ensureEquationOverlay();
            if (!field || !input || !overlay) return;
            const fr = field.getBoundingClientRect();
            const ir = input.getBoundingClientRect();
            const left = ir.left - fr.left;
            const top = ir.top - fr.top;
            overlay.style.left = left + 'px';
            overlay.style.top = top + 'px';
            overlay.style.width = ir.width + 'px';
            overlay.style.height = ir.height + 'px';
            overlay.style.padding = window.getComputedStyle(input).padding;
            overlay.style.lineHeight = window.getComputedStyle(input).lineHeight;
            overlay.style.fontSize = window.getComputedStyle(input).fontSize;
            overlay.style.fontFamily = window.getComputedStyle(input).fontFamily;
        }
        function escapeHTML(s) {
            return (s || '').replace(/[&<>"']/g, (ch) => {
                switch (ch) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return ch;
                }
            });
        }
        function renderColoredPlainEquation(text, opts) {
            const wantTheta = !!(opts && opts.theta);
            const wantR = !!(opts && opts.radius);
            const wantAmp = !!(opts && opts.amp);
            const wantFreq = !!(opts && opts.freq);
            const wantShift = !!(opts && opts.shift);
            if (!text) return '';

            const trigNames = new Set(['sin','cos','tan','asin','acos','atan','sec','csc','cot','asec','acsc','acot']);
            const isLetter = (ch) => /[A-Za-z]/.test(ch);
            const isDigit = (ch) => /[0-9]/.test(ch);
            const isWord = (ch) => /[A-Za-z0-9_]/.test(ch);

            // Tokenizer: preserves raw text slices and indices
            function tokenize(s) {
                const tokens = [];
                let i = 0;
                while (i < s.length) {
                    const ch = s[i];
                    // whitespace
                    if (/\s/.test(ch)) {
                        const start = i;
                        while (i < s.length && /\s/.test(s[i])) i++;
                        tokens.push({ type: 'WS', start, end: i, text: s.slice(start, i) });
                        continue;
                    }
                    // greek symbols
                    if (ch === 'Î¸') { tokens.push({ type: 'THETA', start: i, end: i + 1, text: 'Î¸' }); i++; continue; }
                    if (ch === 'Ï€') { tokens.push({ type: 'PI', start: i, end: i + 1, text: 'Ï€' }); i++; continue; }
                    // operators / punctuation
                    if ('+-*/^=(),'.includes(ch)) { tokens.push({ type: 'OP', start: i, end: i + 1, text: ch }); i++; continue; }
                    // number (e.g., 3, 3.2, .5)
                    if (isDigit(ch) || (ch === '.' && i + 1 < s.length && isDigit(s[i + 1]))) {
                        const start = i;
                        if (ch === '.') i++;
                        while (i < s.length && isDigit(s[i])) i++;
                        if (i < s.length && s[i] === '.') {
                            i++;
                            while (i < s.length && isDigit(s[i])) i++;
                        }
                        tokens.push({ type: 'NUM', start, end: i, text: s.slice(start, i) });
                        continue;
                    }
                    // identifiers
                    if (isLetter(ch)) {
                        const start = i;
                        while (i < s.length && isLetter(s[i])) i++;
                        const raw = s.slice(start, i);
                        const lower = raw.toLowerCase();
                        if (lower === 'theta') tokens.push({ type: 'THETA', start, end: i, text: raw });
                        else if (lower === 'pi') tokens.push({ type: 'PI', start, end: i, text: raw });
                        else if (lower === 'x') tokens.push({ type: 'THETA', start, end: i, text: raw }); // treat x as theta for highlighting
                        else tokens.push({ type: 'IDENT', start, end: i, text: raw });
                        continue;
                    }
                    // fallback single char
                    tokens.push({ type: 'OTHER', start: i, end: i + 1, text: ch });
                    i++;
                }
                return tokens;
            }

            const tokens = tokenize(text);
            const n = tokens.length;
            const nextNonWs = (idx) => {
                let j = idx;
                while (j < n && tokens[j].type === 'WS') j++;
                return j < n ? j : -1;
            };
            const prevNonWs = (idx) => {
                let j = idx;
                while (j >= 0 && tokens[j].type === 'WS') j--;
                return j >= 0 ? j : -1;
            };

            // Find trig calls as token ranges: IDENT '(' ... ')'
            function findMatchingCloseParen(openIdx) {
                let depth = 0;
                for (let j = openIdx; j < n; j++) {
                    if (tokens[j].type === 'OP' && tokens[j].text === '(') depth++;
                    else if (tokens[j].type === 'OP' && tokens[j].text === ')') {
                        depth--;
                        if (depth === 0) return j;
                    }
                }
                return -1;
            }
            const trigCalls = [];
            for (let i = 0; i < n; i++) {
                const t = tokens[i];
                if (t.type !== 'IDENT') continue;
                const name = t.text.toLowerCase();
                if (!trigNames.has(name)) continue;
                const open = nextNonWs(i + 1);
                if (open === -1) continue;
                if (!(tokens[open].type === 'OP' && tokens[open].text === '(')) continue;
                const close = findMatchingCloseParen(open);
                if (close === -1) continue;
                trigCalls.push({ nameTok: i, openTok: open, closeTok: close });
                i = close; // skip over call
            }

            // Mark tokens with classes (priority: freq > amp > shift)
            const mark = new Map(); // tokenIdx -> { cls, prio }
            function setMark(idx, cls, prio) {
                if (idx < 0 || idx >= n) return;
                const t = tokens[idx];
                if (!(t.type === 'NUM' || t.type === 'PI')) return;
                const prev = mark.get(idx);
                if (!prev || prio > prev.prio) mark.set(idx, { cls, prio });
            }

            // Frequency: coefficient on theta inside trig args
            if (wantFreq && trigCalls.length) {
                for (const call of trigCalls) {
                    for (let j = call.openTok + 1; j < call.closeTok; j++) {
                        if (tokens[j].type !== 'THETA') continue;
                        const p1 = prevNonWs(j - 1);
                        const p2 = prevNonWs(p1 - 1);
                        const n1 = nextNonWs(j + 1);
                        const n2 = nextNonWs(n1 + 1);
                        // a * theta
                        if (p1 !== -1 && tokens[p1].type === 'OP' && tokens[p1].text === '*' && p2 !== -1) {
                            setMark(p2, 'token-freq', 3);
                        }
                        // implicit a theta (e.g., 2theta, 2Î¸)
                        if (p1 !== -1 && (tokens[p1].type === 'NUM' || tokens[p1].type === 'PI')) {
                            if (tokens[p1].end === tokens[j].start) {
                                setMark(p1, 'token-freq', 3);
                            }
                        }
                        // theta * a
                        if (n1 !== -1 && tokens[n1].type === 'OP' && tokens[n1].text === '*' && n2 !== -1) {
                            setMark(n2, 'token-freq', 3);
                        }
                        // theta / a
                        if (n1 !== -1 && tokens[n1].type === 'OP' && tokens[n1].text === '/' && n2 !== -1) {
                            setMark(n2, 'token-freq', 3);
                        }
                    }
                }
            }

            // Amplitude: coefficient outside trig call (mult/div right next to the call)
            if (wantAmp && trigCalls.length) {
                for (const call of trigCalls) {
                    const left1 = prevNonWs(call.nameTok - 1);
                    const left2 = prevNonWs(left1 - 1);
                    const right1 = nextNonWs(call.closeTok + 1);
                    const right2 = nextNonWs(right1 + 1);

                    // a * sin(...)
                    if (left1 !== -1 && tokens[left1].type === 'OP' && tokens[left1].text === '*' && left2 !== -1) {
                        setMark(left2, 'token-amp', 2);
                    }
                    // a / sin(...)
                    if (left1 !== -1 && tokens[left1].type === 'OP' && tokens[left1].text === '/' && left2 !== -1) {
                        setMark(left2, 'token-amp', 2);
                    }
                    // implicit a sin(...) (e.g., 2sin(theta))
                    if (left1 !== -1 && (tokens[left1].type === 'NUM' || tokens[left1].type === 'PI')) {
                        if (tokens[left1].end === tokens[call.nameTok].start) {
                            setMark(left1, 'token-amp', 2);
                        }
                    }
                    // sin(...) * a
                    if (right1 !== -1 && tokens[right1].type === 'OP' && tokens[right1].text === '*' && right2 !== -1) {
                        setMark(right2, 'token-amp', 2);
                    }
                    // sin(...) / a
                    if (right1 !== -1 && tokens[right1].type === 'OP' && tokens[right1].text === '/' && right2 !== -1) {
                        setMark(right2, 'token-amp', 2);
                    }
                }
            }

            // Shifts: numbers added/subtracted (inside and outside trig) => value after a binary +/-
            if (wantShift) {
                for (let i = 0; i < n; i++) {
                    const t = tokens[i];
                    if (!(t.type === 'OP' && (t.text === '+' || t.text === '-'))) continue;
                    const l = prevNonWs(i - 1);
                    const r = nextNonWs(i + 1);
                    if (l === -1 || r === -1) continue;
                    const lt = tokens[l];
                    // treat as binary only when left token can be an operand
                    const leftIsOperand = (
                        lt.type === 'NUM' || lt.type === 'PI' || lt.type === 'THETA' ||
                        (lt.type === 'IDENT') ||
                        (lt.type === 'OP' && lt.text === ')')
                    );
                    if (!leftIsOperand) continue;
                    setMark(r, 'token-shift', 1);
                }
            }

            // Render tokens -> HTML with spans
            let out = '';
            for (let i = 0; i < n; i++) {
                const t = tokens[i];
                const raw = t.text;
                // theta highlight
                if (wantTheta && t.type === 'THETA') {
                    out += '<span class="token-theta">' + escapeHTML(raw) + '</span>';
                    continue;
                }
                // r highlight (standalone "r")
                if (wantR && t.type === 'IDENT' && t.text.toLowerCase() === 'r') {
                    const prevCh = t.start > 0 ? text[t.start - 1] : '';
                    const nextCh = t.end < text.length ? text[t.end] : '';
                    if (!isWord(prevCh) && !isWord(nextCh)) {
                        out += '<span class="token-r">' + escapeHTML(raw) + '</span>';
                        continue;
                    }
                }
                // numeric / pi highlights
                if (t.type === 'NUM' || t.type === 'PI') {
                    const m = mark.get(i);
                    if (m) {
                        out += '<span class="' + m.cls + '">' + escapeHTML(raw) + '</span>';
                        continue;
                    }
                }
                out += escapeHTML(raw);
            }
            return out;
        }
        function updateEquationOverlay() {
            const field = document.querySelector('.equation-field');
            const input = document.getElementById('equation');
            const overlay = ensureEquationOverlay();
            if (!field || !input || !overlay) return;
            const thetaEl = document.getElementById('toggleTheta');
            const radiusEl = document.getElementById('toggleRadius');
            const colorRadiusEl = document.getElementById('toggleColorRadius');
            const ampEl = document.getElementById('toggleAmp');
            const freqEl = document.getElementById('toggleFreq');
            const shiftsEl = document.getElementById('toggleShifts');
            const colorThetaOn = !!(thetaEl && thetaEl.checked);
            const colorROn = !!((radiusEl && radiusEl.checked) || (colorRadiusEl && colorRadiusEl.checked));
            const colorAmpOn = !!(ampEl && ampEl.checked);
            const colorFreqOn = !!(freqEl && freqEl.checked);
            const colorShiftOn = !!(shiftsEl && shiftsEl.checked);
            const shouldShow = colorThetaOn || colorROn || colorAmpOn || colorFreqOn || colorShiftOn;
            if (!shouldShow) {
                field.classList.remove('overlay-active');
                overlay.style.display = 'none';
                return;
            }
            // Sync geometry and content
            positionEquationOverlay();
            overlay.innerHTML = renderColoredPlainEquation(input.value || '', {
                theta: colorThetaOn,
                radius: colorROn,
                amp: colorAmpOn,
                freq: colorFreqOn,
                shift: colorShiftOn
            });
            overlay.style.display = 'block';
            field.classList.add('overlay-active');
        }
        // Insert implicit multiplication so inputs like "sin(3x)", "2pi", "(x+1)(x-1)" work without explicit '*'
        function addImplicitMultiplication(expr) {
            if (!expr || typeof expr !== 'string') return expr;
            
            // 1) Number followed by (variable|constant|function|()
            //    e.g., 3theta -> 3*theta, 2pi -> 2*pi, 4sin(theta) -> 4*sin(theta), 5(x+1) -> 5*(x+1)
            //    Avoid touching numbers that are part of identifiers like "log10(".
            expr = expr.replace(/(\d+(?:\.\d+)?)(?=\s*(?:theta|r|pi|sin|cos|tan|asin|acos|atan|sec|csc|cot|asec|acsc|acot|sqrt|log|exp|abs|square|\())/g, function(match, num, offset, str) {
                const prev = offset > 0 ? str[offset - 1] : '';
                if (prev && /[A-Za-z0-9_.]/.test(prev)) {
                    return match; // skip numbers that are part of identifiers (e.g., log10)
                }
                return num + '*';
            });
            
            // 2) (variable|constant|')') followed by (variable|constant|function|'(' | number)
            //    e.g., theta(x+1) -> theta*(x+1), pi theta -> pi*theta, )( -> )*(, r2 -> r*2
            expr = expr.replace(/(\btheta\b|\br\b|\bpi\b|\))(?=\s*(?:\btheta\b|\br\b|\bpi\b|sin|cos|tan|asin|acos|atan|sec|csc|cot|asec|acsc|acot|sqrt|log|exp|abs|square|\(|\d+(?:\.\d+)?))/g, '$1*');
            
            return expr;
        }

        // Preprocess equation to handle various function names and variables
        function preprocessEquation(equation) {
            // Replace common function names
            let processed = equation
                // Convert pretty symbols back to ASCII for mathjs
                .replace(/âˆš/g, 'sqrt')
                .replace(/Ã·/g, '/')
                // Normalize inverse trig synonyms and notations
                .replace(/\barcsin\b/gi, 'asin')
                .replace(/\barccos\b/gi, 'acos')
                .replace(/\barctan\b/gi, 'atan')
                // sin^-1(x) style
                .replace(/sin\s*\^\s*-?\s*1\s*\(/gi, 'asin(')
                .replace(/cos\s*\^\s*-?\s*1\s*\(/gi, 'acos(')
                .replace(/tan\s*\^\s*-?\s*1\s*\(/gi, 'atan(')
                // Convert superscript runs (e.g., xÂ²Â³ -> x^23)
                .replace(/([â°Â¹Â²Â³â´âµâ¶â·â¸â¹âºâ»]+)/g, (m) => {
                    const map = { 'â°':'0','Â¹':'1','Â²':'2','Â³':'3','â´':'4','âµ':'5','â¶':'6','â·':'7','â¸':'8','â¹':'9','âº':'+','â»':'-' };
                    let digits = '';
                    for (const ch of m) digits += (map[ch] || '');
                    return digits ? '^' + digits : '';
                })
                .replace(/\bsqrt\b/g, 'sqrt')
                .replace(/\bsquare\b/g, 'square')
                .replace(/Î¸/g, 'theta')
                .replace(/\btheta\b/g, 'theta')
                // IMPORTANT: don't use \b word boundaries for Ï€; JS \b doesn't treat Ï€ as a word char.
                // Convert both the pretty Ï€ symbol and any typed "pi"/"PI" back to mathjs' "pi".
                .replace(/Ï€/g, 'pi')
                .replace(/Î /g, 'pi')
                .replace(/\bPI\b/g, 'pi')
                // Treat x as theta and y as r (canonicalize variables)
                .replace(/\bx\b/g, 'theta')
                .replace(/\by\b/g, 'r');
            // Convert absolute value bars |...| into abs(...)
            processed = (function convertAbsBarsToAbsCalls(expr) {
                if (!expr || typeof expr !== 'string' || expr.indexOf('|') === -1) return expr;
                let i = 0;
                function parseSegment(stopChar) {
                    let out = '';
                    while (i < expr.length) {
                        const ch = expr[i];
                        if (stopChar && ch === stopChar) {
                            i++;
                            return { out, closed: true };
                        }
                        if (ch === '|') {
                            i++;
                            const inner = parseSegment('|');
                            if (inner.closed) out += 'abs(' + inner.out + ')';
                            else out += '|' + inner.out; // unmatched open bar: keep literal
                            continue;
                        }
                        out += ch;
                        i++;
                    }
                    return { out, closed: false };
                }
                return parseSegment(null).out;
            })(processed);
            // Add implicit multiplication so inputs like "sin(3x)" evaluate correctly
            processed = addImplicitMultiplication(processed);
            return processed;
        }

        // Extract r-exponent and RHS expression from an input.
        // - If equation contains '=', parse LHS as r or r^n and use its exponent.
        // - Otherwise, use UI uiRExponent and treat the whole input as RHS.
        function extractRExponentAndRHS(equation) {
            const processed = preprocessEquation(equation);
            if (processed.includes('=')) {
                const parts = processed.split('=');
                const lhs = parts[0].trim();
                const rhs = parts.slice(1).join('=').trim();
                let exp = 1;
                const m = lhs.match(/^\s*r\s*(?:\^\s*([+\-]?\d+(?:\.\d+)?))?\s*$/i);
                if (m) {
                    if (m[1] !== undefined) {
                        const parsed = parseFloat(m[1]);
                        if (isFinite(parsed)) exp = parsed;
                    }
                }
                return { exponent: exp, rhs };
            } else {
                const exp = (typeof uiRExponent === 'number' ? uiRExponent : 1);
                return { exponent: exp, rhs: processed };
            }
        }

        // Compute r from r^exponent = value. Returns NaN if not real.
        function applyExponentToValue(value, exponent) {
            const n = parseFloat(exponent);
            if (!isFinite(n) || Math.abs(n - 1) < 1e-12) return value;
            if (!isFinite(value)) return NaN;
            if (Math.abs(n) < 1e-12) return NaN; // r^0 = value not supported
            if (Number.isInteger(n)) {
                if (n % 2 === 0) {
                    if (value < 0) return NaN;
                    return Math.pow(Math.abs(value), 1 / n); // principal (positive) root
                } else {
                    return Math.sign(value) * Math.pow(Math.abs(value), 1 / n);
                }
            } else {
                if (value < 0) return NaN;
                return Math.pow(value, 1 / n);
            }
        }

        // Detect which variables are used in the equation
        function detectVariables(equation) {
            const hasR = /\br\b/.test(equation);
            const hasTheta = /\btheta\b/.test(equation);
            // Canonical variables only
            return { hasX: false, hasY: false, hasR, hasTheta };
        }

        function plotGraph() {
            const equation = equationInput.value.trim();
            if (!equation) {
                return;
            }

            try {
                const processed = preprocessEquation(equation);
                const vars = detectVariables(processed);

                // Extract RHS and exponent for validation
                const { exponent: testExp, rhs: rhsExpr } = extractRExponentAndRHS(equation);
                // If an equality is present, require the left side to include r
                if (processed.includes('=')) {
                    const parts = processed.split('=');
                    const lhs = parts[0].trim();
                    if (!/\br\b/.test(lhs)) {
                        throw new Error("When using '=', put r on the left, e.g., r = f(theta)");
                    }
                }
                const testExpr = rhsExpr
                    .replace(/\br\b/g, '(1)')
                    .replace(/\btheta\b/g, '(1)')
                    .replace(/\bx\b/g, '(1)');
                let testVal = math.evaluate(testExpr);
                if (typeof testVal === 'object' && testVal.re !== undefined) testVal = testVal.re;
                void applyExponentToValue(testVal, testExp);

                plotCartesian(processed, vars);
                plotPolar(processed, vars);
                errorMessage.classList.remove('show');
                // Keep range inputs synced with view
                updateRangeInputsFromView();
            } catch (error) {
                showError('Invalid equation: ' + error.message);
            }
        }

        // Quick visibility check: does the cartesian function intersect current viewport?
        function cartesianFunctionIntersectsViewport(equation, vars, xMin, xMax, yMin, yMax) {
            // Decide which variable drives the horizontal axis (Î¸ by default, fallback to x)
            let iterateVar = 'theta';
            if (vars.hasX && !vars.hasTheta && !vars.hasR) {
                iterateVar = 'x';
            }
            const { exponent: effExp, rhs: rhsEquation } = extractRExponentAndRHS(equation);

            const samples = 256; // coarse sampling for a fast visibility test
            const step = (xMax - xMin) / samples;

            for (let i = 0; i <= samples; i++) {
                const val = xMin + i * step;
                try {
                    let expr = equation;
                    let y;

                    if (iterateVar === 'theta') {
                        const theta = val;
                        expr = rhsEquation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        let base = math.evaluate(expr);
                        if (typeof base === 'object' && base.re !== undefined) base = base.re;
                        y = applyExponentToValue(base, effExp);
                    } else {
                        const x = val;
                        expr = rhsEquation.replace(/\bx\b/g, `(${x})`);
                        let base = math.evaluate(expr);
                        if (typeof base === 'object' && base.re !== undefined) base = base.re;
                        y = applyExponentToValue(base, effExp);
                    }

                    if (typeof y === 'object' && y.re !== undefined) {
                        y = y.re;
                    }

                    if (!isNaN(y) && isFinite(y) && y >= yMin && y <= yMax) {
                        return true; // intersects the visible y-range
                    }
                } catch (e) {
                    // ignore individual evaluation errors during visibility sampling
                }
            }

            return false;
        }

        function plotCartesian(equation, vars) {
            const ctx = cartesianCanvas.getContext('2d');
            const width = cartesianCanvas.width;
            const height = cartesianCanvas.height;
            const padding = 60;
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            // Set up coordinate system from view (zoom + center drive the range)
            const baseRangeView = 10 / cartesianZoom;
            const xMin = cartesianCenterX - baseRangeView;
            const xMax = cartesianCenterX + baseRangeView;
            const yMin = cartesianCenterY - baseRangeView;
            const yMax = cartesianCenterY + baseRangeView;
            
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;
            // Provide a consistent baseRange for thresholds/label logic
            const baseRange = Math.max(xRange, yRange) / 2;

            // Update zoom info
            // Optional status text could go here if UI is reintroduced

            // Draw grid (world-aligned with nice steps)
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            function niceStepForRange(range) {
                const targetLines = 10;
                const rough = range / targetLines;
                if (rough <= 0) return 1;
                
                const pow10 = Math.pow(10, Math.floor(Math.log10(Math.abs(rough))));
                const n = Math.abs(rough) / pow10;
                let nice;
                
                // Gradual scaling: prefer larger steps, scale down slowly
                // 10, 5, 2, 1, 0.5, 0.2, 0.1, etc.
                if (n > 7) nice = 10;
                else if (n > 3) nice = 5;
                else if (n > 1.5) nice = 2;
                else if (n > 0.7) nice = 1;
                else if (n > 0.35) nice = 0.5;
                else if (n > 0.15) nice = 0.2;
                else if (n > 0.07) nice = 0.1;
                else if (n > 0.035) nice = 0.05;
                else if (n > 0.015) nice = 0.02;
                else nice = 0.01;
                
                return nice * pow10;
            }

            // Prefer Ï€-based steps for theta axis when reasonable
            function niceThetaStepForRange(range) {
                const candidates = [
                    2 * Math.PI,
                    Math.PI,
                    Math.PI / 2,
                    Math.PI / 3,
                    Math.PI / 4,
                    Math.PI / 6,
                    Math.PI / 8,
                    Math.PI / 12
                ];
                const targetLines = 10;
                let best = { step: candidates[0], score: Infinity };
                for (const cand of candidates) {
                    const ticks = range / cand;
                    const score = Math.abs(ticks - targetLines);
                    if (score < best.score) best = { step: cand, score };
                }
                // If the chosen Ï€-step would produce too many or too few lines, fallback
                const ticks = range / best.step;
                if (ticks > 24 || ticks < 4) {
                    return niceStepForRange(range);
                }
                return best.step;
            }

            const gridXStep = niceThetaStepForRange(xRange);
            const gridYStep = niceStepForRange(yRange);
            
            // Check if we'll be showing decimals
            const defaultRange = 10;
            const effectiveZoom = defaultRange / baseRange;
            const willShowXDecimals = (effectiveZoom >= 2.0 && gridXStep < 1) || 
                                      (effectiveZoom >= 3.0 && gridXStep >= 1 && gridXStep < 10);
            const willShowYDecimals = (effectiveZoom >= 2.0 && gridYStep < 1) || 
                                      (effectiveZoom >= 3.0 && gridYStep >= 1 && gridYStep < 10);
            
            // Draw X grid lines
            const xStartGrid = Math.ceil(xMin / gridXStep) * gridXStep;
            for (let gx = xStartGrid; gx <= xMax + 1e-9; gx += gridXStep) {
                const px = padding + ((gx - xMin) / xRange) * plotWidth;
                const isWholeNumber = willShowXDecimals && (Math.abs(gx % 1) < 0.0001 || 
                                    Math.abs(gx - Math.round(gx)) < 0.0001);
                
                // Make whole number lines darker when decimals are present
                if (isWholeNumber) {
                    ctx.strokeStyle = '#c0c0c0';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                }
                
                ctx.beginPath();
                ctx.moveTo(px, padding);
                ctx.lineTo(px, height - padding);
                ctx.stroke();
            }
            
            // Draw Y grid lines
            const yStartGrid = Math.ceil(yMin / gridYStep) * gridYStep;
            for (let gy = yStartGrid; gy <= yMax + 1e-9; gy += gridYStep) {
                const py = padding + ((yMax - gy) / yRange) * plotHeight;
                const isWholeNumber = willShowYDecimals && (Math.abs(gy % 1) < 0.0001 || 
                                    Math.abs(gy - Math.round(gy)) < 0.0001);
                
                // Make whole number lines darker when decimals are present
                if (isWholeNumber) {
                    ctx.strokeStyle = '#c0c0c0';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                }
                
                ctx.beginPath();
                ctx.moveTo(padding, py);
                ctx.lineTo(width - padding, py);
                ctx.stroke();
            }
            
            // Reset stroke style
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            // y=0 mapped to screen (clamped to nearest edge if out of view)
            let xAxisY = padding + ((yMax - 0) / yRange) * plotHeight;
            xAxisY = Math.max(padding, Math.min(height - padding, xAxisY));
            // x=0 mapped to screen (clamped to nearest edge if out of view)
            let yAxisX = padding + ((0 - xMin) / xRange) * plotWidth;
            yAxisX = Math.max(padding, Math.min(width - padding, yAxisX));

            // X-axis
            ctx.beginPath();
            ctx.moveTo(padding, xAxisY);
            ctx.lineTo(width - padding, xAxisY);
            ctx.stroke();

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(yAxisX, padding);
            ctx.lineTo(yAxisX, height - padding);
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            const xLabelStep = gridXStep;
            const xLabelStart = Math.ceil(xMin / xLabelStep) * xLabelStep;
            // Cap decimals at 1-2 max for cleaner look
            let xDecimals = 0;
            if (willShowXDecimals) {
                if (xLabelStep < 1) {
                    if (xLabelStep >= 0.1) {
                        xDecimals = 1;
                    } else if (xLabelStep >= 0.01) {
                        xDecimals = 2;
                    } else {
                        // For very small steps, cap at 2 decimals
                        xDecimals = 2;
                    }
                } else if (xLabelStep >= 1 && xLabelStep < 10) {
                    xDecimals = 1;
                }
            }
            for (let xv = xLabelStart; xv <= xMax + 1e-9; xv += xLabelStep) {
                if (Math.abs(xv) > xLabelStep * 0.05) {
                    const x = padding + ((xv - xMin) / xRange) * plotWidth;
                    ctx.fillText(formatTheta(xv), x, xAxisY + 20);
                }
            }
            ctx.textAlign = 'right';
            const yLabelStep = gridYStep;
            const yLabelStart = Math.ceil(yMin / yLabelStep) * yLabelStep;
            // Cap decimals at 1-2 max for cleaner look
            let yDecimals = 0;
            if (willShowYDecimals) {
                if (yLabelStep < 1) {
                    if (yLabelStep >= 0.1) {
                        yDecimals = 1;
                    } else if (yLabelStep >= 0.01) {
                        yDecimals = 2;
                    } else {
                        // For very small steps, cap at 2 decimals
                        yDecimals = 2;
                    }
                } else if (yLabelStep >= 1 && yLabelStep < 10) {
                    yDecimals = 1;
                }
            }
            for (let yv = yLabelStart; yv <= yMax + 1e-9; yv += yLabelStep) {
                if (Math.abs(yv) > yLabelStep * 0.05) {
                    const y = padding + ((yMax - yv) / yRange) * plotHeight;
                    ctx.fillText(yv.toFixed(yDecimals), yAxisX - 10, y + 4);
                }
            }

            // Always use Î¸ for x-axis and r for y-axis
            const xLabel = 'Î¸';
            const yLabel = 'r';

            // Draw axis labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(xLabel, width - padding - 20, xAxisY + 35);
            ctx.textAlign = 'right';
            ctx.fillText(yLabel, yAxisX - 25, padding + 15);

            // Plot the function
            // If the function does not intersect the current viewport, skip drawing it
            if (!cartesianFunctionIntersectsViewport(equation, vars, xMin, xMax, yMin, yMax)) {
                return;
            }

            const { exponent: effExp, rhs: rhsEquation } = extractRExponentAndRHS(equation);

            const colorRadiusOn = !!(document.getElementById('toggleColorRadius') && document.getElementById('toggleColorRadius').checked);
            const CURVE_DEFAULT = '#667eea';
            const COLOR_POS = '#60a5fa'; // light blue for r > 0 (top)
            const COLOR_NEG = '#1e3a8a'; // dark blue for r < 0 (bottom)
            const step = (xMax - xMin) / (plotWidth * 2); // Adaptive step size
            let iterateVar = 'theta';
            if (vars.hasX && !vars.hasTheta && !vars.hasR) {
                iterateVar = 'x';
            }
            const start = xMin;
            let end = xMax;
            if (sliderMode === 'drawing') {
                end = Math.min(xMax, Math.max(xMin, sliderTheta));
            }
            if (!colorRadiusOn) {
                ctx.strokeStyle = CURVE_DEFAULT;
                ctx.lineWidth = 3;
                ctx.beginPath();
                let firstPoint = true;
                let lastY = null;
                for (let val = start; val <= end; val += step) {
                    try {
                        let expr = equation;
                        let y;
                        if (iterateVar === 'theta') {
                            const theta = val;
                            expr = rhsEquation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                            let base = math.evaluate(expr);
                            if (typeof base === 'object' && base.re !== undefined) base = base.re;
                            y = applyExponentToValue(base, effExp);
                        } else {
                            const x = val;
                            expr = rhsEquation.replace(/\bx\b/g, `(${x})`);
                            let base = math.evaluate(expr);
                            if (typeof base === 'object' && base.re !== undefined) base = base.re;
                            y = applyExponentToValue(base, effExp);
                        }
                        if (typeof y === 'object' && y.re !== undefined) y = y.re;
                        if (isNaN(y) || !isFinite(y) || y < yMin - baseRange || y > yMax + baseRange) {
                            firstPoint = true;
                            lastY = null;
                            continue;
                        }
                        const plotX = padding + ((val - xMin) / xRange) * plotWidth;
                        const plotY = padding + ((yMax - y) / yRange) * plotHeight;
                        if (firstPoint) {
                            ctx.moveTo(plotX, plotY);
                            firstPoint = false;
                        } else {
                            if (lastY !== null && Math.abs(y - lastY) > baseRange * 2) {
                                ctx.moveTo(plotX, plotY);
                            } else {
                                ctx.lineTo(plotX, plotY);
                            }
                        }
                        lastY = y;
                    } catch (_) {
                        firstPoint = true;
                    }
                }
                ctx.stroke();
            } else {
                // Color-code by sign of r
                ctx.lineWidth = 3;
                let lastY = null;
                let prevSign = null;
                let drawing = false;
                for (let val = start; val <= end; val += step) {
                    try {
                        let expr = equation;
                        let y;
                        if (iterateVar === 'theta') {
                            const theta = val;
                            expr = rhsEquation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                            let base = math.evaluate(expr);
                            if (typeof base === 'object' && base.re !== undefined) base = base.re;
                            y = applyExponentToValue(base, effExp);
                        } else {
                            const x = val;
                            expr = rhsEquation.replace(/\bx\b/g, `(${x})`);
                            let base = math.evaluate(expr);
                            if (typeof base === 'object' && base.re !== undefined) base = base.re;
                            y = applyExponentToValue(base, effExp);
                        }
                        if (typeof y === 'object' && y.re !== undefined) y = y.re;
                        if (isNaN(y) || !isFinite(y) || y < yMin - baseRange || y > yMax + baseRange) {
                            if (drawing) { ctx.stroke(); drawing = false; }
                            prevSign = null;
                            lastY = null;
                            continue;
                        }
                        const plotX = padding + ((val - xMin) / xRange) * plotWidth;
                        const plotY = padding + ((yMax - y) / yRange) * plotHeight;
                        const sign = (y > 0) ? 1 : (y < 0 ? -1 : 0);
                        const color = (sign < 0) ? COLOR_NEG : COLOR_POS;
                        if (!drawing || prevSign !== sign) {
                            if (drawing) ctx.stroke();
                            ctx.beginPath();
                            ctx.strokeStyle = color;
                            ctx.moveTo(plotX, plotY);
                            drawing = true;
                        } else {
                            // Only break line on actual discontinuities (very large jumps), not just large value changes
                            // This prevents white spaces when amplitude changes
                            if (lastY !== null && Math.abs(y - lastY) > baseRange * 10) {
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.strokeStyle = color;
                                ctx.moveTo(plotX, plotY);
                            } else {
                                ctx.lineTo(plotX, plotY);
                            }
                        }
                        prevSign = sign;
                        lastY = y;
                    } catch (_) {
                        if (drawing) { ctx.stroke(); drawing = false; }
                        prevSign = null;
                        lastY = null;
                    }
                }
                if (drawing) ctx.stroke();
            }

            // Draw point at slider position
            if (sliderTheta >= xMin && sliderTheta <= xMax) {
                try {
                    let expr = equation;
                    let y;
                    
                    if (iterateVar === 'theta') {
                        const theta = sliderTheta;
                        expr = rhsEquation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        let base = math.evaluate(expr);
                        if (typeof base === 'object' && base.re !== undefined) base = base.re;
                        y = applyExponentToValue(base, effExp);
                    } else {
                        const x = sliderTheta;
                        expr = rhsEquation.replace(/\bx\b/g, `(${x})`);
                        let base = math.evaluate(expr);
                        if (typeof base === 'object' && base.re !== undefined) base = base.re;
                        y = applyExponentToValue(base, effExp);
                    }

                    if (typeof y === 'object' && y.re !== undefined) {
                        y = y.re;
                    }

                    if (!isNaN(y) && isFinite(y) && y >= yMin - baseRange && y <= yMax + baseRange) {
                        const plotX = padding + ((sliderTheta - xMin) / xRange) * plotWidth;
                        const plotY = padding + ((yMax - y) / yRange) * plotHeight;

                        // Always draw the traveling point in red (even when radius is color-coded)
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.arc(plotX, plotY, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw a light border for visibility
                        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                } catch (error) {
                    // Ignore errors when drawing point
                }
            }

            // Overlay: Theta horizontal base on x-axis and Amplitude helper guides
            const thetaToggle = document.getElementById('toggleTheta');
            if (thetaToggle && thetaToggle.checked) {
                // Draw horizontal base along y = 0 from x = 0 to x = sliderTheta
                const x0Val = 0;
                const x1Val = sliderTheta;
                // Map to screen
                const x0 = padding + ((x0Val - xMin) / xRange) * plotWidth;
                const x1 = padding + ((x1Val - xMin) / xRange) * plotWidth;
                // y = 0 mapped and clamped already
                let xAxisY = padding + ((yMax - 0) / yRange) * plotHeight;
                xAxisY = Math.max(padding, Math.min(height - padding, xAxisY));
                ctx.save();
                ctx.setLineDash([6, 4]);
                ctx.strokeStyle = '#9333ea'; // theta color (muted purple)
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x0, xAxisY);
                ctx.lineTo(x1, xAxisY);
                ctx.stroke();
                ctx.restore();
            }

            const ampToggle = document.getElementById('toggleAmp');
            if (ampToggle && ampToggle.checked) {
                const GUIDE_COLOR = '#ea580c'; // darker orange to match the amp toggle button
                const GUIDE_DASH = [6, 4];

                // IMPORTANT:
                // The amplitude "midline" should be based on the *entire function domain* (full Î¸ range),
                // not only what is currently visible in the viewport (and not truncated by drawing mode).
                //
                // We still compute *visible* extrema separately below for on-screen connector lines.
                let domainMin = xMin;
                let domainMax = xMax;
                if (iterateVar === 'theta') {
                    const sliderEl = document.getElementById('thetaSlider');
                    const aMin = sliderEl ? parseFloat(sliderEl.dataset.actualMin || '') : NaN;
                    const aMax = sliderEl ? parseFloat(sliderEl.dataset.actualMax || '') : NaN;
                    if (isFinite(aMin) && isFinite(aMax) && aMin !== aMax) {
                        domainMin = Math.min(aMin, aMax);
                        domainMax = Math.max(aMin, aMax);
                    }
                }
                if (!isFinite(domainMin) || !isFinite(domainMax) || !(domainMax > domainMin)) {
                    // If view is invalid for any reason, bail out of amp helpers safely.
                    domainMin = null;
                    domainMax = null;
                }
                const extremaSamples = 2048;
                const dx = (domainMin !== null && domainMax !== null) ? ((domainMax - domainMin) / extremaSamples) : 0;
                let eqMinY = Infinity;
                let eqMaxY = -Infinity;

                function evalYAt(val) {
                    try {
                        let y;
                        if (iterateVar === 'theta') {
                            const theta = val;
                            const expr = rhsEquation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                            let base = math.evaluate(expr);
                            if (typeof base === 'object' && base.re !== undefined) base = base.re;
                            y = applyExponentToValue(base, effExp);
                        } else {
                            const x = val;
                            const expr = rhsEquation.replace(/\bx\b/g, `(${x})`);
                            let base = math.evaluate(expr);
                            if (typeof base === 'object' && base.re !== undefined) base = base.re;
                            y = applyExponentToValue(base, effExp);
                        }
                        if (typeof y === 'object' && y.re !== undefined) y = y.re;
                        if (!isFinite(y)) return NaN;
                        return y;
                    } catch (_) {
                        return NaN;
                    }
                }

                if (domainMin === null || domainMax === null) {
                    // nothing to do
                } else for (let i = 0; i <= extremaSamples; i++) {
                    const xVal = domainMin + i * dx;
                    const yVal = evalYAt(xVal);
                    if (!isFinite(yVal)) { continue; }
                    eqMinY = Math.min(eqMinY, yVal);
                    eqMaxY = Math.max(eqMaxY, yVal);
                }

                // Amplitude "midline": y = k where k is halfway between the function's min and max
                const yMidVal = (isFinite(eqMinY) && isFinite(eqMaxY)) ? ((eqMinY + eqMaxY) / 2) : ((yMin + yMax) / 2);
                const yMidPx = padding + ((yMax - yMidVal) / yRange) * plotHeight;
                const midlineVisible = isFinite(yMidPx) && yMidPx >= padding && yMidPx <= (height - padding);

                // Draw the horizontal midline
                if (midlineVisible) {
                    ctx.save();
                    ctx.setLineDash(GUIDE_DASH);
                    ctx.strokeStyle = GUIDE_COLOR;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'butt';
                    ctx.beginPath();
                    ctx.moveTo(padding, yMidPx);
                    ctx.lineTo(width - padding, yMidPx);
                    ctx.stroke();
                    ctx.restore();
                }

                // Find *visible* local extrema (mins/maxes) so we can draw perpendicular connectors
                // for every min/max currently on screen.
                const visibleExtrema = [];
                if (isFinite(xMin) && isFinite(xMax) && xMax > xMin) {
                    // In drawing mode, the cartesian curve is only drawn up to the slider.
                    const visXMax = (sliderMode === 'drawing' && isFinite(sliderTheta))
                        ? Math.min(xMax, Math.max(xMin, sliderTheta))
                        : xMax;
                    if (isFinite(visXMax) && visXMax > xMin) {
                        const visSamples = Math.min(4096, Math.max(768, Math.floor(plotWidth * 2)));
                        const visDx = (visXMax - xMin) / visSamples;

                        // Sample y values and compute an amplitude-aware tolerance so extrema detection
                        // works even when the viewport yRange is large.
                        const ys = new Array(visSamples + 1);
                        let visMinY = Infinity;
                        let visMaxY = -Infinity;

                        function evalYVisible(val) {
                            const y = evalYAt(val);
                            // Match the curve renderer's notion of drawable points (small margin via baseRange).
                            if (!isFinite(y) || y < (yMin - baseRange) || y > (yMax + baseRange)) return NaN;
                            return y;
                        }

                        for (let i = 0; i <= visSamples; i++) {
                            const xv = xMin + i * visDx;
                            const yv = evalYVisible(xv);
                            ys[i] = yv;
                            if (isFinite(yv)) {
                                if (yv < visMinY) visMinY = yv;
                                if (yv > visMaxY) visMaxY = yv;
                            }
                        }

                        const curveRange = (isFinite(visMinY) && isFinite(visMaxY)) ? (visMaxY - visMinY) : 0;
                        // Epsilon for turn detection: must be small enough to work at any zoom.
                        // Using viewport yRange can be far too large and suppress all extrema.
                        const visEps = Math.max(1e-12, curveRange * 1e-6);

                        // Extrema detection: look for slope sign changes and then refine the extremum location
                        // using a local quadratic (parabola) fit over 3 samples. This avoids the connector line
                        // being "shifted forward" by up to one sample step.
                        for (let i = 1; i < visSamples; i++) {
                            const yL = ys[i - 1];
                            const yC = ys[i];
                            const yR = ys[i + 1];
                            if (!isFinite(yL) || !isFinite(yC) || !isFinite(yR)) continue;

                            const dy1 = yC - yL;
                            const dy2 = yR - yC;

                            // Turn detection: sign change in slope with a small magnitude gate
                            const turnMag = Math.abs(dy1) + Math.abs(dy2);
                            const isMax = (dy1 > 0 && dy2 < 0 && turnMag > visEps);
                            const isMin = (dy1 < 0 && dy2 > 0 && turnMag > visEps);
                            if (!isMax && !isMin) continue;

                            // Parabola fit with x = -1, 0, +1 around i:
                            // a = (yL - 2yC + yR) / 2, b = (yR - yL) / 2, c = yC
                            const a = (yL - 2 * yC + yR) / 2;
                            const b = (yR - yL) / 2;
                            let xOff = 0; // in sample steps, relative to center i
                            if (Math.abs(a) > 1e-15) {
                                xOff = -b / (2 * a); // vertex location in [-1,1] typically
                                if (!isFinite(xOff)) xOff = 0;
                                xOff = Math.max(-1, Math.min(1, xOff));
                            }
                            const yV = a * xOff * xOff + b * xOff + yC;
                            const xV = (xMin + i * visDx) + xOff * visDx;

                            if (!isFinite(xV) || !isFinite(yV)) continue;
                            visibleExtrema.push({ kind: isMax ? 'max' : 'min', x: xV, y: yV });
                        }

                        // De-duplicate adjacent extrema (sampling can produce 2 very close turning points)
                        const deduped = [];
                        for (const ex of visibleExtrema) {
                            const last = deduped[deduped.length - 1];
                            if (last && ex.kind === last.kind && Math.abs(ex.x - last.x) <= visDx * 4) continue;
                            deduped.push(ex);
                        }
                        visibleExtrema.length = 0;
                        deduped.forEach(e => visibleExtrema.push(e));
                    }
                }

                // Draw perpendicular connectors from the midline to each visible extrema
                if (midlineVisible && visibleExtrema.length) {
                    ctx.save();
                    ctx.setLineDash(GUIDE_DASH);
                    ctx.strokeStyle = GUIDE_COLOR;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'butt';
                    const ampRaw = (isFinite(editParams.amplitude) ? editParams.amplitude : 1);
                    const ampN = Math.max(1, Math.round(Math.abs(ampRaw)));
                    for (const ex of visibleExtrema) {
                        const px = padding + ((ex.x - xMin) / xRange) * plotWidth;
                        let py = padding + ((yMax - ex.y) / yRange) * plotHeight;
                        if (!isFinite(px) || !isFinite(py)) continue;
                        // only draw if the extremum is visible in the current viewport
                        if (ex.x < xMin || ex.x > xMax) continue;
                        if (py < padding || py > height - padding) continue;
                        // clamp into plot area
                        const cx = Math.max(padding, Math.min(width - padding, px));
                        py = Math.max(padding, Math.min(height - padding, py));
                        ctx.beginPath();
                        ctx.moveTo(cx, yMidPx);
                        ctx.lineTo(cx, py);
                        ctx.stroke();

                        // Split the connector (midline -> extrema) into equal segments by amplitude number,
                        // using small tickmarks (same idea as the polar amplitude ticks).
                        const len = Math.abs(py - yMidPx);
                        if (ampN > 1 && isFinite(len) && len > 10) {
                            const tickHalf = 6;
                            const y0 = yMidPx;
                            const y1 = py;
                            for (let i = 1; i < ampN; i++) {
                                const t = i / ampN;
                                const ty = y0 + (y1 - y0) * t;

                                // Outline + inner stroke so ticks stand out on the curve/grid
                                ctx.save();
                                ctx.setLineDash([]); // solid ticks
                                ctx.lineCap = 'round';
                                // outline
                                ctx.strokeStyle = 'rgba(17,24,39,0.85)';
                                ctx.lineWidth = 4;
                                ctx.beginPath();
                                ctx.moveTo(cx - tickHalf, ty);
                                ctx.lineTo(cx + tickHalf, ty);
                                ctx.stroke();
                                // inner
                                ctx.strokeStyle = GUIDE_COLOR;
                                ctx.lineWidth = 2.5;
                                ctx.beginPath();
                                ctx.moveTo(cx - tickHalf, ty);
                                ctx.lineTo(cx + tickHalf, ty);
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                    }
                    ctx.restore();
                }
            }
            const radiusToggle = document.getElementById('toggleRadius');
            if (radiusToggle && radiusToggle.checked) {
                const rAtTheta = evaluateRAtTheta(sliderTheta);
                if (isFinite(rAtTheta) && rAtTheta >= yMin - baseRange && rAtTheta <= yMax + baseRange) {
                    // Vertical segment at x = sliderTheta from y = 0 to y = r(theta)
                    const sx = padding + ((sliderTheta - xMin) / xRange) * plotWidth;
                    const y0 = padding + ((yMax - 0) / yRange) * plotHeight; // x-axis Y
                    const y1 = padding + ((yMax - rAtTheta) / yRange) * plotHeight;
                    ctx.save();
                    ctx.setLineDash([6, 4]);
                    ctx.strokeStyle = '#dc2626'; // radius color (muted red)
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(sx, y0);
                    ctx.lineTo(sx, y1);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Overlay: Shifts point (where the original y-intercept point lands after shifts)
            // Example: sin(theta - 4) + 5 -> point at (4, 5) because sin(0) = 0.
            const shiftsToggle = document.getElementById('toggleShifts');
            if (shiftsToggle && shiftsToggle.checked) {
                try {
                    let xVal = 0;
                    let yVal = 0;

                    if (sliderSessionActive) {
                        // Slider-driven shifts: use editParams against the base equation
                        xVal = (isFinite(editParams.thetaShift) ? editParams.thetaShift : 0);
                        const amp = (isFinite(editParams.amplitude) ? editParams.amplitude : 1);
                        const rShift = (isFinite(editParams.rShift) ? editParams.rShift : 0);

                        // Evaluate the *base* equation at theta = 0 to get the original y-intercept y-value.
                        const baseEq = (editBaseEquation || '').trim() || (equationInput.value || '').trim();
                        const baseParts = extractRExponentAndRHS(baseEq);
                        const baseRhs = baseParts.rhs || baseEq;
                        const baseExp = baseParts.exponent || 1;
                        const theta = 0;
                        const baseExpr = baseRhs
                            .replace(/\btheta\b/g, `(${theta})`)
                            .replace(/Î¸/g, `(${theta})`)
                            .replace(/\bx\b/g, `(${theta})`);
                        let yBase = math.evaluate(baseExpr);
                        if (typeof yBase === 'object' && yBase && yBase.re !== undefined) yBase = yBase.re;
                        yBase = applyExponentToValue(yBase, baseExp);
                        if (typeof yBase === 'object' && yBase && yBase.re !== undefined) yBase = yBase.re;
                        yVal = amp * yBase + rShift;
                    } else {
                        // Typed-equation shifts: infer phase shift from the equation itself (e.g., sin(theta - pi/4))
                        const inferred = detectThetaShiftFromEquation(equationInput.value || '');
                        xVal = (isFinite(inferred) ? inferred : 0);
                        // The "landing point" of the original y-intercept after a horizontal shift is at (xShift, r(xShift))
                        yVal = evaluateRAtTheta(xVal);
                    }

                    if (isFinite(xVal) && isFinite(yVal) && xVal >= xMin && xVal <= xMax && yVal >= yMin && yVal <= yMax) {
                        const px = padding + ((xVal - xMin) / xRange) * plotWidth;
                        const py = padding + ((yMax - yVal) / yRange) * plotHeight;

                        // Dotted yellow guides from axes to the point
                        ctx.save();
                        ctx.setLineDash([6, 4]);
                        ctx.strokeStyle = '#facc15'; // yellow
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'butt';

                        // From x-axis (y = 0) up/down to the point
                        if (0 >= yMin && 0 <= yMax) {
                            let xAxisY = padding + ((yMax - 0) / yRange) * plotHeight;
                            xAxisY = Math.max(padding, Math.min(height - padding, xAxisY));
                            ctx.beginPath();
                            ctx.moveTo(px, xAxisY);
                            ctx.lineTo(px, py);
                            ctx.stroke();
                        }

                        // From y-axis (x = 0) across to the point
                        if (0 >= xMin && 0 <= xMax) {
                            let yAxisX = padding + ((0 - xMin) / xRange) * plotWidth;
                            yAxisX = Math.max(padding, Math.min(width - padding, yAxisX));
                            ctx.beginPath();
                            ctx.moveTo(yAxisX, py);
                            ctx.lineTo(px, py);
                            ctx.stroke();
                        }
                        ctx.restore();

                        ctx.save();
                        // Match the red traveling point style: solid fill + light border
                        ctx.fillStyle = '#facc15'; // yellow
                        ctx.beginPath();
                        ctx.arc(px, py, 5, 0, 2 * Math.PI);
                        ctx.fill();

                        // Light border for visibility (same as red point)
                        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.restore();
                    }
                } catch (_) {
                    // ignore shifts point draw errors
                }
            }
        }

        function plotPolar(equation, vars) {
            const ctx = polarCanvas.getContext('2d');
            // If not sized yet, try to size now
            if (!polarCanvas.width || !polarCanvas.height) {
                setupCanvas(polarCanvas);
            }
            let width = polarCanvas.width;
            let height = polarCanvas.height;
            // If still invalid, bail early
            if (!width || !height) return;
            const centerX = width / 2;
            const centerY = height / 2;
            const polarPadding = 10;
            const baseRadius = Math.min(width, height) / 2 - polarPadding;

            const { exponent: effExp, rhs: rhsEquation } = extractRExponentAndRHS(equation);

            // Determine a stable r-extent independent of the cartesian view.
            // Use the slider's configured domain (or [0, 2Ï€]) to sample r(Î¸).
            let actualMin = 0;
            let actualMax = 2 * Math.PI;
            const sliderElForDomain = document.getElementById('thetaSlider');
            if (sliderElForDomain) {
                actualMin = parseFloat(sliderElForDomain.dataset.actualMin || '0');
                actualMax = parseFloat(sliderElForDomain.dataset.actualMax || (2 * Math.PI).toString());
            }
            // Track last polar state for hover mapping
            lastPolarState = { centerX, centerY, maxR: 1, radiusPx: baseRadius };
            
            // Sample to find max r from the function to ensure we show the full function
            const sampleStep = 0.01;
            const sampleThetaMin = actualMin;
            const sampleThetaMax = actualMax;
            let functionMaxR = 1; // fallback to keep grid usable
            
            for (let theta = sampleThetaMin; theta <= sampleThetaMax; theta += sampleStep * 10) {
                try {
                    let expr = rhsEquation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                    let rBase = math.evaluate(expr);
                    if (typeof rBase === 'object' && rBase.re !== undefined) rBase = rBase.re;
                    let r = applyExponentToValue(rBase, effExp);
                    if (typeof r === 'object' && r.re !== undefined) {
                        r = r.re;
                    }
                    if (!isNaN(r) && isFinite(r)) {
                        functionMaxR = Math.max(functionMaxR, Math.abs(r) * 1.1);
                    }
                } catch (e) {}
            }
            
            // Use function range as the primary maxR; keep a minimum to avoid divide-by-zero
            let maxR = functionMaxR;
            if (!isFinite(maxR) || maxR <= 0) {
                maxR = 1;
            }
            // If editing, freeze the polar scale to avoid jumpy resizing
            if (interactionMode === 'edit' && editLockedMaxR && isFinite(editLockedMaxR)) {
                maxR = editLockedMaxR;
            }
            // Apply polar zoom (independent of cartesian view)
            maxR = maxR / polarZoom;
            const radius = baseRadius;
            lastPolarState.maxR = maxR;
            lastPolarState.radiusPx = radius;

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            // Draw concentric circles with adaptive increments
            // Scale gradually: start with whole numbers, then 0.5, then smaller increments
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Choose a circle step that adapts gradually to zoom level
            // Scale more slowly: 10, 5, 2, 1, 0.5, 0.2, 0.1, etc.
            const maxCircles = 12; // Reduced from 16 for cleaner look
            function chooseNiceStep(range, maxTicks) {
                const rough = range / maxTicks;
                if (rough <= 0) return 1;
                
                const pow10 = Math.pow(10, Math.floor(Math.log10(Math.abs(rough))));
                const n = Math.abs(rough) / pow10;
                let nice;
                
                // Gradual scaling: prefer larger steps, only go smaller when really needed
                if (n > 7) nice = 10;
                else if (n > 3) nice = 5;
                else if (n > 1.5) nice = 2;
                else if (n > 0.7) nice = 1;
                else if (n > 0.35) nice = 0.5;
                else if (n > 0.15) nice = 0.2;
                else if (n > 0.07) nice = 0.1;
                else if (n > 0.035) nice = 0.05;
                else if (n > 0.015) nice = 0.02;
                else nice = 0.01;
                
                return nice * pow10;
            }
            
            // Always choose an appropriate step based on maxR
            let circleStep = chooseNiceStep(maxR, maxCircles);
            
            // Ensure we have a reasonable number of circles
            let numCircles = Math.floor(maxR / circleStep);
            if (numCircles > maxCircles) {
                // Too many circles, increase step size
                circleStep = chooseNiceStep(maxR, maxCircles);
                numCircles = Math.floor(maxR / circleStep);
            } else if (numCircles < 4 && maxR > circleStep * 4) {
                // Too few circles, decrease step size slightly
                const smallerStep = circleStep / 2;
                const newNumCircles = Math.floor(maxR / smallerStep);
                if (newNumCircles <= maxCircles && newNumCircles >= 4) {
                    circleStep = smallerStep;
                    numCircles = newNumCircles;
                }
            }

            // Determine if we'll be showing decimals (needed for whole number highlighting)
            const totalZoom = polarZoom;
            let willShowDecimals = false;
            if (totalZoom >= 2.0) {
                if (circleStep < 1 || (circleStep === 0.5 && totalZoom >= 2.5) || 
                    (circleStep >= 1 && circleStep < 10 && totalZoom >= 3.0)) {
                    willShowDecimals = true;
                }
            }
            
            // Draw concentric circles
            for (let i = 1; i <= numCircles; i++) {
                const r = i * circleStep;
                // Whole-number radii get darker lines than decimals
                const isWholeNumber = Math.abs(r - Math.round(r)) < 1e-8;
                
                // Make whole number circles darker when decimals are present
                if (isWholeNumber) {
                    ctx.strokeStyle = '#c0c0c0';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                }
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, (r / maxR) * radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Reset stroke style
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Draw radial lines (more angles: every 15Â°)
            for (let angle = 0; angle < 360; angle += 15) {
                const rad = (angle * Math.PI) / 180;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + radius * Math.cos(rad),
                    centerY + radius * Math.sin(rad)
                );
                ctx.stroke();
            }

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - radius, centerY);
            ctx.lineTo(centerX + radius, centerY);
            ctx.moveTo(centerX, centerY - radius);
            ctx.lineTo(centerX, centerY + radius);
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            const labelOffsetY = 6;
            ctx.fillText('0', centerX, centerY - labelOffsetY);
            
            // Always choose enough decimal precision to avoid repeated labels.
            // Compute decimals from the step size; cap to 2 for readability.
            // Examples: step=0.5 -> 1 dec, 0.2 -> 1 dec, 0.05 -> 2 dec.
            const decimals = Math.min(2, Math.max(0, Math.ceil(-Math.log10(circleStep + 1e-12))));
            
            let lastLabel = null;
            let lastLabelX = -Infinity;
            const minLabelSpacing = 18; // px minimum spacing to avoid condensed labels
            for (let i = 1; i <= numCircles; i++) {
                const r = i * circleStep;
                const label = r.toFixed(decimals);
                const xPos = centerX + (r / maxR) * radius;
                // Skip drawing duplicate labels caused by rounding and avoid overlap
                if (label !== lastLabel && (xPos - lastLabelX) >= minLabelSpacing) {
                    ctx.fillText(label, xPos, centerY - labelOffsetY);
                    lastLabel = label;
                    lastLabelX = xPos;
                }
            }
            
            // Update zoom info
            // Optional polar zoom status can be surfaced in UI if desired

            // Plot the polar function (optionally color-code by sign of r)
            const colorRadiusOn = !!(document.getElementById('toggleColorRadius') && document.getElementById('toggleColorRadius').checked);
            const CURVE_DEFAULT_POLAR = '#764ba2';
            const COLOR_POS = '#60a5fa'; // light blue for r > 0 (top)
            const COLOR_NEG = '#1e3a8a'; // dark blue for r < 0 (bottom)
            const step = 0.01;
            let thetaMin = actualMin;
            let thetaMax = actualMax;
            if (sliderMode === 'drawing') {
                thetaMin = actualMin;
                thetaMax = Math.min(actualMax, Math.max(actualMin, sliderTheta));
            }
            if (!colorRadiusOn) {
                ctx.strokeStyle = CURVE_DEFAULT_POLAR;
                ctx.lineWidth = 3;
                ctx.beginPath();
                let firstPoint = true;
                for (let theta = thetaMin; theta <= thetaMax; theta += step) {
                    try {
                        let expr = rhsEquation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        let rBase = math.evaluate(expr);
                        if (typeof rBase === 'object' && rBase.re !== undefined) rBase = rBase.re;
                        let r = applyExponentToValue(rBase, effExp);
                        if (typeof r === 'object' && r.re !== undefined) r = r.re;
                        if (isNaN(r) || !isFinite(r)) { firstPoint = true; continue; }
                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        const plotX = centerX + (x / maxR) * radius;
                        const plotY = centerY - (y / maxR) * radius;
                        if (plotX >= 0 && plotX <= width && plotY >= 0 && plotY <= height) {
                            if (firstPoint) { ctx.moveTo(plotX, plotY); firstPoint = false; }
                            else { ctx.lineTo(plotX, plotY); }
                        } else {
                            firstPoint = true;
                        }
                    } catch (_) { firstPoint = true; }
                }
                ctx.stroke();
            } else {
                ctx.lineWidth = 3;
                let drawing = false;
                let prevSign = null;
                let firstPoint = true;
                for (let theta = thetaMin; theta <= thetaMax; theta += step) {
                    try {
                        let expr = rhsEquation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        let rBase = math.evaluate(expr);
                        if (typeof rBase === 'object' && rBase.re !== undefined) rBase = rBase.re;
                        let r = applyExponentToValue(rBase, effExp);
                        if (typeof r === 'object' && r.re !== undefined) r = r.re;
                        if (isNaN(r) || !isFinite(r)) { if (drawing) { ctx.stroke(); drawing = false; } firstPoint = true; prevSign = null; continue; }
                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        const plotX = centerX + (x / maxR) * radius;
                        const plotY = centerY - (y / maxR) * radius;
                        const sign = (r > 0) ? 1 : (r < 0 ? -1 : 0);
                        const color = (sign < 0) ? COLOR_NEG : COLOR_POS;
                        if (!drawing || prevSign !== sign) {
                            if (drawing) ctx.stroke();
                            ctx.beginPath();
                            ctx.strokeStyle = color;
                            ctx.moveTo(plotX, plotY);
                            drawing = true;
                            firstPoint = false;
                        } else {
                            ctx.lineTo(plotX, plotY);
                        }
                        prevSign = sign;
                    } catch (_) {
                        if (drawing) { ctx.stroke(); drawing = false; }
                        firstPoint = true;
                        prevSign = null;
                    }
                }
                if (drawing) ctx.stroke();
            }

            // Draw point at slider position
            if (sliderTheta >= thetaMin && sliderTheta <= thetaMax) {
                try {
                    let expr = rhsEquation.replace(/\btheta\b/g, `(${sliderTheta})`).replace(/\bx\b/g, `(${sliderTheta})`);
                    let rBase = math.evaluate(expr);
                    if (typeof rBase === 'object' && rBase.re !== undefined) rBase = rBase.re;
                    let r = applyExponentToValue(rBase, effExp);

                    if (typeof r === 'object' && r.re !== undefined) {
                        r = r.re;
                    }

                    if (!isNaN(r) && isFinite(r)) {
                        // Convert polar to cartesian
                        const x = r * Math.cos(sliderTheta);
                        const y = r * Math.sin(sliderTheta);

                        // Scale to canvas coordinates
                        const plotX = centerX + (x / maxR) * radius;
                        const plotY = centerY - (y / maxR) * radius;

                        // Always draw the traveling point in red (even when radius is color-coded)
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.arc(plotX, plotY, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw a light border for visibility
                        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                } catch (error) {
                    // Ignore errors when drawing point
                }
            }

            // Overlays: theta arc slice, theta-to-curve line, and radius line(s)
            const thetaToggle = document.getElementById('toggleTheta');
            let thetaArcR = null;
            if (thetaToggle && thetaToggle.checked) {
                ctx.save();
                // Draw an arc slice from 0 to sliderTheta near the origin (counter-clockwise in math coords)
                ctx.strokeStyle = '#9333ea'; // theta color (muted purple)
                ctx.lineWidth = 2;
                const arcR = Math.max(18, Math.min(radius * 0.22, 60)); // small arc radius
                thetaArcR = arcR;
                const step = Math.max(0.02, Math.min(0.1, Math.abs(sliderTheta) / 24));
                ctx.beginPath();
                for (let a = 0; a <= sliderTheta + 1e-9; a += step) {
                    const px = centerX + arcR * Math.cos(a);
                    const py = centerY - arcR * Math.sin(a);
                    if (a === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                // Theta symbol near the middle of the arc
                const mid = sliderTheta / 2;
                const tx = centerX + (arcR + 12) * Math.cos(mid);
                const ty = centerY - (arcR + 12) * Math.sin(mid);
                ctx.fillStyle = '#9333ea';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Î¸', tx, ty);
                ctx.restore();
            }

            // Overlay: Shifts shown in polar:
            // - x-shift as an angle from 0 (arc + dashed radial)
            // - y-shift as a SOLID yellow radial segment drawn over the dashed radial
            const shiftsToggle = document.getElementById('toggleShifts');
            let shiftArcR = null;
            const shiftTheta = (isFinite(editParams.thetaShift) ? editParams.thetaShift : 0);
            const yShiftRaw = (isFinite(editParams.rShift) ? editParams.rShift : 0);
            const yShiftMag = Math.abs(yShiftRaw);
            const yShiftPxRaw = (isFinite(yShiftMag) ? (yShiftMag / maxR) * radius : 0);
            const yShiftPx = Math.max(0, Math.min(radius - 10, yShiftPxRaw));
            const yShiftLabel = (yShiftRaw < 0 ? '-y' : 'y');

            if (shiftsToggle && shiftsToggle.checked && (isFinite(shiftTheta) || isFinite(yShiftPx))) {
                // Slightly larger arc than theta so they don't overlap as much.
                // If y-shift is larger than this arc radius, we use y-shift as the arc's radial reference.
                const baseArcR = (typeof thetaArcR === 'number' && isFinite(thetaArcR))
                    ? thetaArcR + 18
                    : Math.max(18, Math.min(radius * 0.26, 72));
                const desiredArcR = Math.max(baseArcR, yShiftPx);
                shiftArcR = Math.max(18, Math.min(desiredArcR, radius - 10));

                // Draw x-shift arc (only when x-shift is non-zero)
                if (isFinite(shiftTheta) && Math.abs(shiftTheta) > 1e-12) {
                    ctx.save();
                    ctx.strokeStyle = '#facc15'; // yellow
                    ctx.lineWidth = 2;
                    const absT = Math.abs(shiftTheta);
                    const step = Math.max(0.02, Math.min(0.1, absT / 24));
                    const dir = shiftTheta >= 0 ? 1 : -1;
                    ctx.beginPath();
                    for (let a = 0; (dir > 0 ? a <= shiftTheta + 1e-9 : a >= shiftTheta - 1e-9); a += dir * step) {
                        const px = centerX + shiftArcR * Math.cos(a);
                        const py = centerY - shiftArcR * Math.sin(a);
                        if (a === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();

                    // Label near the middle of the arc
                    const mid = shiftTheta / 2;
                    const tx = centerX + (shiftArcR + 12) * Math.cos(mid);
                    const ty = centerY - (shiftArcR + 12) * Math.sin(mid);
                    ctx.fillStyle = '#facc15';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('x', tx, ty);
                    ctx.restore();
                }
            }

            // Overlay: Amplitude in polar (orange dashed)
            // Draw a line from the origin to the max-radius point, constrained to be perpendicular
            // to the y-shift reference direction (which is drawn along shiftTheta when shifts are enabled).
            const ampToggle = document.getElementById('toggleAmp');
            if (ampToggle && ampToggle.checked) {
                const baseDir = (isFinite(shiftTheta) ? shiftTheta : 0);
                const perp = baseDir + Math.PI / 2;

                function evalRAt(theta) {
                    try {
                        let expr = rhsEquation.replace(/\btheta\b/g, `(${theta})`).replace(/\bx\b/g, `(${theta})`);
                        let rBase = math.evaluate(expr);
                        if (typeof rBase === 'object' && rBase.re !== undefined) rBase = rBase.re;
                        let r = applyExponentToValue(rBase, effExp);
                        if (typeof r === 'object' && r.re !== undefined) r = r.re;
                        return (isFinite(r) ? r : NaN);
                    } catch (_) {
                        return NaN;
                    }
                }

                // There are two antipodal rays perpendicular to baseDir. Check both.
                const t1 = perp;
                const t2 = perp + Math.PI;
                const r1 = evalRAt(t1);
                const r2 = evalRAt(t2);

                let thetaSel = null;
                let rSel = null;
                if (isFinite(r1) && isFinite(r2)) {
                    if (Math.abs(r2) > Math.abs(r1)) { thetaSel = t2; rSel = r2; }
                    else { thetaSel = t1; rSel = r1; }
                } else if (isFinite(r1)) { thetaSel = t1; rSel = r1; }
                else if (isFinite(r2)) { thetaSel = t2; rSel = r2; }

                if (thetaSel !== null && isFinite(rSel) && isFinite(maxR) && maxR > 0) {
                    // Polar to cartesian (handles negative r naturally)
                    const x = rSel * Math.cos(thetaSel);
                    const y = rSel * Math.sin(thetaSel);
                    const plotX = centerX + (x / maxR) * radius;
                    const plotY = centerY - (y / maxR) * radius;

                    // Compute screen-space direction for tick placement
                    const lx = plotX - centerX;
                    const ly = plotY - centerY;
                    const lineLen = Math.hypot(lx, ly);
                    const ux = lineLen > 1e-9 ? (lx / lineLen) : 0;
                    const uy = lineLen > 1e-9 ? (ly / lineLen) : 0;

                    ctx.save();
                    ctx.setLineDash([6, 4]);
                    ctx.strokeStyle = '#ea580c'; // darker orange to match the amp toggle button
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'butt';
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(plotX, plotY);
                    ctx.stroke();
                    ctx.restore();

                    // Yellow tickmark on the amplitude line indicating y-shift magnitude
                    // (measured as radius proportional to |rShift|) and direction hint by sign.
                    // Make it very prominent (thicker + outlined) so it's visible over grid/curve.
                    let tickDist = 0;
                    if (isFinite(yShiftPx) && yShiftPx > 1e-9 && lineLen > 1e-9) {
                        tickDist = Math.max(0, Math.min(lineLen, yShiftPx));
                        const tx = centerX + ux * tickDist;
                        const ty = centerY + uy * tickDist;
                        // Perpendicular tick direction (flip for negative y-shift)
                        const sign = (yShiftRaw < 0) ? -1 : 1;
                        const px = -uy * sign;
                        const py = ux * sign;
                        const tickHalf = 10; // larger half-length so the tick is obvious
                        const x0 = tx - px * tickHalf;
                        const y0 = ty - py * tickHalf;
                        const x1 = tx + px * tickHalf;
                        const y1 = ty + py * tickHalf;

                        // Outline pass (dark) + inner pass (bright yellow)
                        ctx.save();
                        ctx.setLineDash([]); // solid tick
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(x0, y0);
                        ctx.lineTo(x1, y1);
                        ctx.strokeStyle = 'rgba(0,0,0,0.55)';
                        ctx.lineWidth = 8;
                        ctx.stroke();
                        ctx.strokeStyle = '#fde047'; // brighter yellow
                        ctx.lineWidth = 4;
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Amp toggle: subdivide only the segment from the yellow tick to the endpoint
                    // by the amplitude number using small orange tickmarks.
                    if (lineLen > 1e-9) {
                        const ampRaw = (isFinite(editParams.amplitude) ? editParams.amplitude : 1);
                        const ampN = Math.max(1, Math.round(Math.abs(ampRaw)));
                        const segLen = Math.max(0, lineLen - tickDist);
                        if (ampN > 1 && segLen > 4) {
                            // Place (ampN - 1) ticks to create ampN equal segments
                            const tickHalf = 6; // slightly larger ticks
                            const px = -uy; // perpendicular to the amplitude line (screen space)
                            const py = ux;
                            ctx.save();
                            ctx.setLineDash([]); // solid ticks
                            // Outline + inner stroke so ticks stand out on the curve
                            ctx.lineCap = 'round';
                            for (let i = 1; i < ampN; i++) {
                                const d = tickDist + (segLen * i) / ampN;
                                const tx = centerX + ux * d;
                                const ty = centerY + uy * d;
                                const x0 = tx - px * tickHalf;
                                const y0 = ty - py * tickHalf;
                                const x1 = tx + px * tickHalf;
                                const y1 = ty + py * tickHalf;
                                ctx.beginPath();
                                ctx.moveTo(x0, y0);
                                ctx.lineTo(x1, y1);
                                ctx.strokeStyle = 'rgba(0,0,0,0.35)';
                                ctx.lineWidth = 6;
                                ctx.stroke();
                                ctx.strokeStyle = '#f97316'; // brighter orange
                                ctx.lineWidth = 3;
                                ctx.stroke();
                            }
                            ctx.restore();
                        }
                    }
                }
            }
            const radiusToggle = document.getElementById('toggleRadius');
            const rAtTheta = evaluateRAtTheta(sliderTheta);

            // Theta toggle ON + Radius toggle OFF: draw a line from origin to the end of the theta arc
            // (forms a pie-slice sector with the arc)
            if (thetaToggle && thetaToggle.checked && (!radiusToggle || !radiusToggle.checked) && typeof thetaArcR === 'number' && isFinite(thetaArcR)) {
                const plotX = centerX + thetaArcR * Math.cos(sliderTheta);
                const plotY = centerY - thetaArcR * Math.sin(sliderTheta);
                ctx.save();
                ctx.setLineDash([6, 4]);
                ctx.strokeStyle = '#9333ea'; // theta color (muted purple)
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(plotX, plotY);
                ctx.stroke();
                ctx.restore();
            }

            // Shifts overlay radial(s):
            // - dashed yellow radial line shows the x-shift direction (to the end of the arc) when Radius is OFF
            // - solid yellow segment shows the y-shift magnitude along that same direction (always when Shifts is ON)
            if (shiftsToggle && shiftsToggle.checked && typeof shiftArcR === 'number' && isFinite(shiftArcR)) {
                const endX = centerX + shiftArcR * Math.cos(shiftTheta);
                const endY = centerY - shiftArcR * Math.sin(shiftTheta);

                // Dashed: x-shift radial reference (kept visible beyond the y segment when y < arc)
                if (!radiusToggle || !radiusToggle.checked) {
                    ctx.save();
                    ctx.setLineDash([6, 4]);
                    ctx.strokeStyle = '#facc15'; // yellow
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    ctx.restore();
                }

                // Solid: y-shift segment (drawn below the radius helper line since radius is drawn later)
                if (isFinite(yShiftPx) && yShiftPx > 1e-9) {
                    const yEndX = centerX + yShiftPx * Math.cos(shiftTheta);
                    const yEndY = centerY - yShiftPx * Math.sin(shiftTheta);
                    ctx.save();
                    ctx.setLineDash([]); // SOLID
                    ctx.strokeStyle = '#facc15'; // yellow
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(yEndX, yEndY);
                    ctx.stroke();

                    // Label 'y' near the end of the solid segment
                    const labelR = Math.min(radius - 4, yShiftPx + 14);
                    const lx = centerX + labelR * Math.cos(shiftTheta);
                    const ly = centerY - labelR * Math.sin(shiftTheta);
                    ctx.fillStyle = '#facc15';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(yShiftLabel, lx, ly);
                    ctx.restore();
                }
            }

            // Radius toggle ON: draw line to the actual point (handles positive and negative r)
            if (radiusToggle && radiusToggle.checked && isFinite(rAtTheta)) {
                const x = rAtTheta * Math.cos(sliderTheta);
                const y = rAtTheta * Math.sin(sliderTheta);
                const plotX = centerX + (x / maxR) * radius;
                const plotY = centerY - (y / maxR) * radius;
                ctx.save();
                // Keep dashed style for consistency with the radius helper line
                ctx.setLineDash([6, 4]);
                ctx.strokeStyle = '#dc2626'; // radius color (muted red)
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(plotX, plotY);
                ctx.stroke();
                ctx.restore();
            }

            // Theta ON + Radius ON + Negative radius: add a dashed light-magenta reference line
            // in the original Î¸ direction with length |r|
            if (thetaToggle && thetaToggle.checked && radiusToggle && radiusToggle.checked && isFinite(rAtTheta) && rAtTheta < 0) {
                const mag = Math.abs(rAtTheta);
                const refX = mag * Math.cos(sliderTheta);
                const refY = mag * Math.sin(sliderTheta);
                const refPlotX = centerX + (refX / maxR) * radius;
                const refPlotY = centerY - (refY / maxR) * radius;
                ctx.save();
                ctx.setLineDash([10, 6]); // dashed
                ctx.strokeStyle = '#e879f9'; // light magenta
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(refPlotX, refPlotY);
                ctx.stroke();
                ctx.restore();
            }
        }

        // Slider functions
        function setSliderMode(mode) {
            sliderMode = mode;
            document.getElementById('modePreDrawn').classList.toggle('active', mode === 'preDrawn');
            document.getElementById('modeDrawing').classList.toggle('active', mode === 'drawing');
            plotGraph();
        }

        function updateSliderRange() {
            const minInput = document.getElementById('sliderMin');
            const maxInput = document.getElementById('sliderMax');
            const minValue = minInput.value.trim();
            const maxValue = maxInput.value.trim();
            
            if (minValue === '') {
                sliderMin = null;
            } else {
                const num = parseFloat(minValue);
                if (!isNaN(num)) {
                    sliderMin = num;
                }
            }
            
            if (maxValue === '') {
                sliderMax = null;
            } else {
                const num = parseFloat(maxValue);
                if (!isNaN(num)) {
                    sliderMax = num;
                }
            }
            
            updateSliderBounds();
            plotGraph();
        }

        function updateSliderBounds() {
            const slider = document.getElementById('thetaSlider');
            const minLabel = document.getElementById('sliderMinLabel');
            const maxLabel = document.getElementById('sliderMaxLabel');
            
            // Determine actual min/max for slider
            let actualMin, actualMax;
            if (sliderMin !== null) {
                actualMin = sliderMin;
            } else {
                // Use periodicity if available, else default to [0, 2Ï€]
                const eq = equationInput.value.trim();
                const p = eq ? detectPeriodicity(preprocessEquation(eq)) : null;
                actualMin = 0;
                if (p && p.period && isFinite(p.period)) {
                    // keep min=0
                } else {
                    // keep min=0 for non-periodic too
                }
            }
            
            if (sliderMax !== null) {
                actualMax = sliderMax;
            } else {
                const eq = equationInput.value.trim();
                const p = eq ? detectPeriodicity(preprocessEquation(eq)) : null;
                if (p && p.period && isFinite(p.period)) {
                    actualMax = p.period;
                } else {
                    actualMax = 2 * Math.PI; // sensible default
                }
            }
            
            // Update slider min/max
            slider.min = 0;
            slider.max = 100;
            
            // Store the actual range for conversion
            slider.dataset.actualMin = actualMin;
            slider.dataset.actualMax = actualMax;
            
            // Update labels
            if (minLabel) minLabel.value = `${formatTheta(actualMin)}`;
            if (maxLabel) maxLabel.value = `${formatTheta(actualMax)}`;
            
            // Update current theta based on slider position
            const sliderValue = parseFloat(slider.value);
            sliderTheta = round2(actualMin + (sliderValue / 100) * (actualMax - actualMin));
            document.getElementById('sliderValue').textContent = `Î¸ = ${formatTheta(sliderTheta)}`;
        }

        function onSliderChange() {
            const slider = document.getElementById('thetaSlider');
            const actualMin = parseFloat(slider.dataset.actualMin || '-6.28');
            const actualMax = parseFloat(slider.dataset.actualMax || '6.28');
            const sliderValue = parseFloat(slider.value);
            
            sliderTheta = round2(actualMin + (sliderValue / 100) * (actualMax - actualMin));
            document.getElementById('sliderValue').textContent = `Î¸ = ${formatTheta(sliderTheta)}`;
            
            plotGraph();
        }

        // Setup slider event listener
        function setupSlider() {
            const slider = document.getElementById('thetaSlider');
            if (slider) {
                slider.addEventListener('input', onSliderChange);
                updateSliderBounds();
            }
            attachSliderLabelEditors();
            attachThetaValueEditor();
            // Keep equation overlay positioned on load
            updateEquationOverlay();
        }

        // Formatting Î¸ values; show clean multiples/fractions of Ï€ when close
        function formatTheta(value) {
            if (!isFinite(value)) return `${value}`;
            const eps = 1e-6;
            const k = value / Math.PI;
            if (Math.abs(k) < eps) return '0';
            const sign = k < 0 ? '-' : '';
            const ak = Math.abs(k);
            const denoms = [1, 2, 3, 4, 6, 8, 12];
            for (const d of denoms) {
                const n = Math.round(ak * d);
                if (Math.abs(ak - n / d) < eps) {
                    if (n === 0) return '0';
                    if (d === 1) {
                        if (n === 1) return `${sign}Ï€`;
                        return `${sign}${n}Ï€`;
                    }
                    if (n === 1) return `${sign}Ï€/${d}`;
                    return `${sign}${n}Ï€/${d}`;
                }
            }
            return value.toFixed(2);
        }

        // ===== Interaction Modes & Helpers =====
        function clamp(min, max, v) { return Math.max(min, Math.min(max, v)); }
        function round2(n) {
            if (!isFinite(n)) return n;
            return Math.round(n * 100) / 100;
        }
        // Snap a number to a fixed increment (used to keep edit-mode dragging from producing long decimals).
        function snapToIncrement(v, step = 0.01) {
            if (!isFinite(v) || !isFinite(step) || step <= 0) return v;
            const snapped = Math.round(v / step) * step;
            // Avoid floating point artifacts like 0.30000000000000004
            return parseFloat(snapped.toFixed(10));
        }
        function snapFactor(v) {
            const step = 0.1; // nicer increments
            const snapped = Math.max(0.05, Math.round(v / step) * step);
            return parseFloat(snapped.toFixed(2));
        }
        function fmtNum(n) {
            if (!isFinite(n)) return `${n}`;
            const r = Math.round(n);
            if (Math.abs(n - r) < 1e-6) return String(r);
            return n.toFixed(2);
        }

        // Equation display numbers: avoid fractions and keep output compact/decimal.
        // (Used for the equation textbox, not for axis labels.)
        function fmtEqNum(n) {
            if (!isFinite(n)) return `${n}`;
            if (Math.abs(n) < 1e-12) return '0';
            const r = Math.round(n);
            if (Math.abs(n - r) < 1e-12) return String(r);

            // If it's a clean multiple/fraction of Ï€, keep it symbolic (pi) so the UI can show Ï€.
            // This also preserves user intent when they typed "pi" in a slider box.
            try {
                const piExpr = formatThetaExpr(n);
                if (typeof piExpr === 'string' && /\bpi\b/i.test(piExpr)) return piExpr;
            } catch (_) {}

            // Otherwise, avoid rounding away precision (especially for shifts).
            // Use a reasonably high precision and strip trailing zeros.
            let s = Number(n).toPrecision(12);
            if (/e/i.test(s)) {
                // For our typical slider ranges this should rarely happen, but keep it readable if it does.
                s = Number(n).toFixed(12);
            }
            return s.replace(/\.?0+$/g, '');
        }

        // Wrap coefficients that include division so implicit multiplication doesn't become ambiguous.
        function wrapMulCoeff(s) {
            if (!s) return s;
            return (String(s).includes('/') ? `(${s})` : String(s));
        }

        function formatThetaExpr(value) {
            if (!isFinite(value)) return `${value}`;
            const eps = 1e-6;
            const k = value / Math.PI;
            if (Math.abs(k) < eps) return '0';
            const sign = k < 0 ? '-' : '';
            const ak = Math.abs(k);
            const denoms = [1, 2, 3, 4, 6, 8, 12];
            for (const d of denoms) {
                const n = Math.round(ak * d);
                if (Math.abs(ak - n / d) < eps) {
                    if (n === 0) return '0';
                    if (d === 1) {
                        if (n === 1) return `${sign}pi`;
                        return `${sign}${n}*pi`;
                    }
                    if (n === 1) return `${sign}pi/${d}`;
                    return `${sign}${n}*pi/${d}`;
                }
            }
            return value.toFixed(3);
        }

        function ensureTooltip() {
            if (!tooltipEl) {
                tooltipEl = document.createElement('div');
                tooltipEl.className = 'hover-tooltip';
                tooltipEl.style.display = 'none';
                document.body.appendChild(tooltipEl);
            }
            return tooltipEl;
        }
        function showCoordTooltip(text, x, y) {
            const el = ensureTooltip();
            el.textContent = text;
            el.style.left = `${x + 12}px`;
            el.style.top = `${y + 12}px`;
            el.style.display = 'block';
        }
        function hideCoordTooltip() {
            if (tooltipEl) tooltipEl.style.display = 'none';
        }

        function setInteractionMode(mode) {
            interactionMode = mode;
            const btnP = document.getElementById('btnModePerspective');
            const btnV = document.getElementById('btnModeView');
            const btnE = document.getElementById('btnModeEdit');
            if (btnP) btnP.classList.toggle('active', mode === 'perspective');
            if (btnV) btnV.classList.toggle('active', mode === 'view');
            if (btnE) btnE.classList.toggle('active', mode === 'edit');
            
            // Show/hide edit adjustment buttons
            const editAdjustButtons = document.getElementById('editAdjustButtons');
            if (editAdjustButtons) {
                editAdjustButtons.style.display = (mode === 'edit') ? 'flex' : 'none';
            }
            
            updateCanvasCursor();
            hideCoordTooltip();
            if (mode === 'edit') {
                // Initialize edit session from current equation
                syncParamsFromEquationInput({ expandBounds: true });
                isEditTranslating = false;
                isEditAdjustingAmplitude = false;
                isEditAdjustingFrequency = false;
                editStart = null;
                editLockedMaxR = (lastPolarState && isFinite(lastPolarState.maxR) && lastPolarState.maxR > 0) ? lastPolarState.maxR : null;
                // Default to shift adjust mode
                editAdjustMode = 'shift';
                // Activate shift button by default
                const adjustBtns = document.querySelectorAll('.adjust-btn');
                adjustBtns.forEach(btn => btn.classList.remove('active'));
                document.getElementById('btnShiftAdjust')?.classList.add('active');
            } else {
                editLockedMaxR = null;
                // Clear active state from adjust buttons when leaving edit mode
                const adjustBtns = document.querySelectorAll('.adjust-btn');
                adjustBtns.forEach(btn => btn.classList.remove('active'));
            }
        }

        function activateAdjustMode(mode) {
            if (interactionMode !== 'edit') return;
            
            // Set the adjust mode
            editAdjustMode = mode;
            
            // Remove active class from all adjust buttons
            const adjustBtns = document.querySelectorAll('.adjust-btn');
            adjustBtns.forEach(btn => btn.classList.remove('active'));
            
            // Add active class to clicked button
            if (mode === 'amplitude') {
                document.getElementById('btnAmplitudeAdjust')?.classList.add('active');
            } else if (mode === 'frequency') {
                document.getElementById('btnFrequencyAdjust')?.classList.add('active');
            } else if (mode === 'shift') {
                document.getElementById('btnShiftAdjust')?.classList.add('active');
            }
            
            // Update cursor based on adjust mode
            updateCanvasCursor();
        }

        function updateCanvasCursor() {
            if (!cartesianCanvas || !polarCanvas) return;
            if (interactionMode === 'perspective') {
                cartesianCanvas.style.cursor = 'grab';
                polarCanvas.style.cursor = 'zoom-in';
            } else if (interactionMode === 'view') {
                cartesianCanvas.style.cursor = 'crosshair';
                polarCanvas.style.cursor = 'crosshair';
            } else {
                // Edit mode: cursor based on adjust mode
                if (editAdjustMode === 'amplitude') {
                    cartesianCanvas.style.cursor = 'ns-resize';
                    polarCanvas.style.cursor = 'ns-resize';
                } else if (editAdjustMode === 'frequency') {
                    cartesianCanvas.style.cursor = 'ew-resize';
                    polarCanvas.style.cursor = 'ew-resize';
                } else {
                    // Shift mode: move cursor (cross with arrows)
                    cartesianCanvas.style.cursor = 'move';
                    polarCanvas.style.cursor = 'move';
                }
            }
        }

        // Show delayed tooltips on toolbar buttons
        (function setupModeTooltips() {
            const toolbar = document.getElementById('interactionToolbar');
            if (!toolbar) return;
            let hoverTimer = null;
            toolbar.querySelectorAll('.icon-btn').forEach(btn => {
                btn.addEventListener('mouseenter', () => {
                    hoverTimer = setTimeout(() => {
                        btn.classList.add('show-tip');
                    }, 600);
                });
                btn.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimer);
                    btn.classList.remove('show-tip');
                });
            });
        })();

        function extractRHSForEditing() {
            const { rhs } = extractRExponentAndRHS(equationInput.value || '');
            return rhs || '';
        }

        function cleanupSliderExpression(expr) {
            if (!expr) return expr;
            if (typeof math === 'undefined' || typeof math.parse !== 'function') return expr;
            try {
                const node = math.parse(expr);
                // Ensure Fraction nodes (from simplify) display as decimals, not "a/b".
                return node.toString({ parenthesis: 'auto', fraction: 'decimal', precision: 14 });
            } catch (_) {
                return expr;
            }
        }

        // --- Helpers to normalize/denormalize theta symbol and simplify/factor linear forms ---
        function normalizeThetaSymbols(s) {
            // Convert 'Î¸' to 'theta' for parsing/mathjs
            return (s || '').replace(/Î¸/g, 'theta');
        }
        function denormalizeThetaSymbols(s) {
            // Convert 'theta' back to 'Î¸' for display/storage
            return (s || '').replace(/\btheta\b/g, 'Î¸');
        }
        function toNumber(value) {
            const n = Number(value);
            return Number.isFinite(n) ? n : NaN;
        }
        function getConstantNumeric(node) {
            try {
                // Evaluate node if it does not depend on 'theta'/'Î¸'/'x'
                const deps = (typeof node.filter === 'function')
                    ? node.filter(n => n.isSymbolNode).map(n => n.name)
                    : [];
                const hasTheta = deps && deps.some(name => name === 'theta' || name === 'Î¸' || name === 'x');
                if (hasTheta) return null;
                // Safe numeric evaluation (pi, e, numbers, arithmetic)
                const v = node.compile().evaluate();
                return (typeof v === 'number' && Number.isFinite(v)) ? v : null;
            } catch (_) {
                return null;
            }
        }
        function cloneNode(n) { try { return math.parse(n.toString()); } catch { return n; } }
        function getLinearFormInTheta(node) {
            // Returns {k, c} if node is linear in theta: k*theta + c, else null
            const eps = 1e-12;
            if (!node || typeof node !== 'object') return null;
            if (node.isParenthesisNode) {
                return getLinearFormInTheta(node.content);
            }
            if (node.isSymbolNode) {
                if (node.name === 'theta' || node.name === 'Î¸') return { k: 1, c: 0 };
                if (node.name === 'x') return { k: 1, c: 0 }; // treat x like theta for factoring when used
                // constants like 'pi', 'e'
                const c = getConstantNumeric(node);
                return (c === null) ? null : { k: 0, c };
            }
            if (node.isConstantNode) {
                const c = toNumber(node.value);
                return Number.isFinite(c) ? { k: 0, c } : null;
            }
            if (node.isOperatorNode) {
                const op = node.op;
                if ((op === '+' || op === '-') && node.args && node.args.length >= 2) {
                    let k = 0, c = 0;
                    for (let i = 0; i < node.args.length; i++) {
                        const a = node.args[i];
                        const lf = getLinearFormInTheta(a);
                        if (!lf) return null;
                        if (i === 0) { k += lf.k; c += lf.c; }
                        else {
                            if (op === '+') { k += lf.k; c += lf.c; }
                            else { k -= lf.k; c -= lf.c; }
                        }
                    }
                    return { k, c };
                }
                if (op === '*' && node.args && node.args.length >= 2) {
                    // Only allow one Î¸-linear factor (k != 0) and the rest pure constants.
                    // IMPORTANT: Constant factors (k=0) are NOT treated as "linear factors".
                    const eps = 1e-12;
                    let acc = 1;
                    let base = null; // {k, c} for the single Î¸-linear factor
                    for (const a of node.args) {
                        const lf = getLinearFormInTheta(a);
                        if (lf && isFinite(lf.k) && Math.abs(lf.k) > eps) {
                            if (base) return null; // more than one Î¸-linear factor => non-linear
                            base = lf;
                            continue;
                        }
                        const val = getConstantNumeric(a);
                        if (val === null || !isFinite(val)) return null;
                        acc *= val;
                    }
                    if (!base) {
                        // Pure constant multiplication
                        return { k: 0, c: acc };
                    }
                    return { k: acc * base.k, c: acc * base.c };
                }
                if (op === '/' && node.args && node.args.length === 2) {
                    const numLF = getLinearFormInTheta(node.args[0]);
                    const denConst = getConstantNumeric(node.args[1]);
                    if (numLF && denConst !== null && denConst !== 0) {
                        return { k: numLF.k / denConst, c: numLF.c / denConst };
                    }
                    return null;
                }
                if ((op === '-' || op === '+') && node.args && node.args.length === 1) {
                    // unary plus/minus
                    const lf = getLinearFormInTheta(node.args[0]);
                    if (!lf) return null;
                    if (op === '+') return lf;
                    return { k: -lf.k, c: -lf.c };
                }
                return null;
            }
            return null;
        }
        function formatLinearTheta(k, c) {
            const eps = 1e-10;
            if (Math.abs(k) < eps) {
                // No theta term; return just constant
                return fmtNum(c);
            }
            const shift = c / k; // k*theta + c = k*(theta + c/k)
            const kStr = (Math.abs(k - 1) < eps) ? '' : `${fmtNum(k)}*`;
            const sAbs = Math.abs(shift);
            const shiftStr = sAbs < eps ? '' : `${shift >= 0 ? '+' : '-'} ${formatThetaExpr(sAbs)}`;
            if (!shiftStr) return `${kStr}theta`;
            return `${kStr}(theta ${shiftStr})`;
        }
        function factorLinearThetaInAST(node) {
            try {
                return node.transform(function (n) {
                    const lf = getLinearFormInTheta(n);
                    if (lf && (Math.abs(lf.k) > 1e-12 || Math.abs(lf.c) > 1e-12)) {
                        // Replace with formatted linear string, using 'theta'
                        const s = formatLinearTheta(lf.k, lf.c);
                        return math.parse(s);
                    }
                    return n;
                });
            } catch (_) {
                return node;
            }
        }

        // For display: rewrite trig args that are linear in Î¸ into phase-shift form:
        //   trig(k*Î¸ + c)  ->  trig(k(Î¸ - a))  where a = -c/k
        // Only applies when |k| != 1 (i.e., there is a multiple on Î¸).
        function factorLinearThetaInTrigArgsForDisplay(node) {
            try {
                if (!node || typeof node.transform !== 'function') return node;
                const trigNames = new Set(['sin', 'cos', 'tan', 'sec', 'csc', 'cot']);
                const eps = 1e-12;
                return node.transform(function (n) {
                    if (!n || !n.isFunctionNode || !Array.isArray(n.args) || n.args.length !== 1) return n;
                    const fnName =
                        (n.fn && typeof n.fn.name === 'string' ? n.fn.name :
                         (typeof n.name === 'string' ? n.name : '')).toLowerCase();
                    if (!trigNames.has(fnName)) return n;

                    const arg = n.args[0];
                    const lf = getLinearFormInTheta(arg);
                    if (!lf || !isFinite(lf.k) || Math.abs(lf.k) < eps) return n;
                    if (Math.abs(Math.abs(lf.k) - 1) < 1e-9) return n;

                    const a = -(lf.c || 0) / lf.k; // a = -c/k (x-shift)
                    const kStr = wrapMulCoeff(fmtEqNum(lf.k));
                    if (!isFinite(a) || Math.abs(a) < 1e-12) {
                        // If shift ~ 0, just show kÎ¸
                        return new math.FunctionNode(n.fn, [math.parse(`${kStr}*theta`)]);
                    }
                    const aAbs = Math.abs(a);
                    const aStr = formatThetaExpr(aAbs);
                    const inner = `theta ${a >= 0 ? '-' : '+'} ${aStr}`;
                    const newArg = `${kStr}*(${inner})`;
                    return new math.FunctionNode(n.fn, [math.parse(newArg)]);
                });
            } catch (_) {
                return node;
            }
        }

        // Fallback (no-mathjs) rewriter for very common typed patterns like:
        //   sin(4Î¸ - 2)  ->  sin(4(Î¸ - 0.5))
        // This runs on the *displayed* equation text and only handles numeric constants.
        function rewriteSimplePhaseShiftInTrigTextForDisplay(s) {
            if (!s || typeof s !== 'string') return s;
            const trig = '(sin|cos|tan|sec|csc|cot)';
            const num = '([+\\-]?\\d+(?:\\.\\d+)?)';
            // Match: fn( k Î¸ +/- c ) with optional '*' between k and Î¸
            const re = new RegExp(`\\b${trig}\\s*\\(\\s*${num}\\s*\\*?\\s*(?:Î¸|theta)\\s*([+\\-])\\s*${num}\\s*\\)`, 'g');
            return s.replace(re, (m, fn, kStrRaw, sign, cStrRaw) => {
                const k = parseFloat(kStrRaw);
                const c = parseFloat(cStrRaw);
                if (!isFinite(k) || Math.abs(k) < 1e-12 || !isFinite(c)) return m;
                // a = c / k, keep sign consistent with original: kÎ¸ - c = k(Î¸ - c/k)
                const a = c / k;
                const aAbs = Math.abs(a);
                const aStr = fmtEqNum(aAbs);
                const kStr = wrapMulCoeff(fmtEqNum(k));
                if (!isFinite(aAbs) || aAbs < 1e-12) return `${fn}(${kStr}${(m.includes('theta') ? 'theta' : 'Î¸')})`;
                const thetaSym = m.includes('theta') ? 'theta' : 'Î¸';
                return `${fn}(${kStr}(${thetaSym} ${sign === '-' ? '-' : '+'} ${aStr}))`;
            });
        }
        function stringifyWithDivisionParentheses(node) {
            try {
                const baseOpts = { parenthesis: 'auto', fraction: 'decimal', precision: 14 };
                const handler = {
                    'OperatorNode': function (n, options) {
                        if (n.op === '/' && n.args && n.args.length === 2) {
                            const l = n.args[0].toString({ ...baseOpts, handler: this });
                            const r = n.args[1].toString({ ...baseOpts, handler: this });
                            return `(${l}) / (${r})`;
                        }
                        // Fallback to default printing for other operators
                        return undefined;
                    }
                };
                return node.toString({ ...baseOpts, handler });
            } catch (_) {
                return node.toString({ parenthesis: 'auto', fraction: 'decimal', precision: 14 });
            }
        }

        // Reorder multiplicative factors so constants appear before Î¸ for nicer display
        // (e.g., Î¸*409 -> 409*Î¸, (Î¸*409)/50 -> (409*Î¸)/50).
        function reorderThetaMultiplicationForDisplay(node) {
            try {
                if (!node || typeof node.transform !== 'function') return node;
                return node.transform(function (n) {
                    if (!n || !n.isOperatorNode || n.op !== '*' || !Array.isArray(n.args) || n.args.length < 2) return n;
                    const args = n.args.slice();
                    let hasTheta = false;
                    for (const a of args) {
                        if (a && a.isSymbolNode && (a.name === 'theta' || a.name === 'Î¸')) { hasTheta = true; break; }
                    }
                    if (!hasTheta) return n;
                    // Stable-ish reorder: constants first, then other non-theta, then theta last.
                    const isConst = (a) => {
                        const v = getConstantNumeric(a);
                        return (v !== null && isFinite(v));
                    };
                    const consts = [];
                    const others = [];
                    const thetas = [];
                    for (const a of args) {
                        if (a && a.isSymbolNode && (a.name === 'theta' || a.name === 'Î¸')) thetas.push(a);
                        else if (isConst(a)) consts.push(a);
                        else others.push(a);
                    }
                    if (!thetas.length) return n;
                    // Only rewrite if it actually changes something
                    const reordered = [...consts, ...others, ...thetas];
                    const same =
                        reordered.length === args.length &&
                        reordered.every((a, i) => a === args[i]);
                    if (same) return n;
                    return new math.OperatorNode('*', 'multiply', reordered);
                });
            } catch (_) {
                return node;
            }
        }

        // Turn safe explicit multiplications into implicit ones for display:
        // - "2*Î¸" -> "2Î¸"
        // - "2*sin(Î¸)" -> "2sin(Î¸)"
        // - "(x+1)*(x-1)" -> "(x+1)(x-1)"
        // Keeps numeric products like "2*3" as-is.
        function makeImplicitMultiplicationDisplay(s) {
            if (!s) return s;
            // number / pi / ')' followed by identifier, 'Î¸', or '('
            // Note: we intentionally do NOT remove '*' before a number to avoid changing "2*3".
            return s.replace(
                /(\b(?:\d+(?:\.\d+)?|\.\d+)|\bpi\b|\))\s*\*\s*(?=(?:\(|Î¸|\b[A-Za-z]+\b))/g,
                '$1'
            );
        }

        // Ensure we don't display "+ -x" sequences; prefer "- x"
        function normalizePlusMinusDisplay(s) {
            if (!s) return s;
            let out = s;
            out = out.replace(/\+\s*-\s*/g, '- ');
            out = out.replace(/-\s*-\s*/g, '+ ');
            out = out.replace(/\+\s*\+\s*/g, '+ ');
            return out;
        }

        function applyEditParamsToEquation(baseEq, params) {
            // Work on RHS only
            const rhsRaw = extractRExponentAndRHS(baseEq).rhs || baseEq;
            const rhs = normalizeThetaSymbols(rhsRaw);
            const freq = params.frequency;
            const amp = params.amplitude;
            const tShift = params.thetaShift;
            const rShift = params.rShift;
            const eps = 1e-12;

            // If the base equation is a simple trig-of-theta, emit a clean form:
            //   A sin(k(Î¸ - s)) + D
            // where s is the x-shift in Î¸-units. (So sin(4Î¸ - 2) is shown as sin(4(Î¸ - 0.5)).)
            const simpleTrig = (rhs || '').trim().match(/^(sin|cos|tan|sec|csc|cot)\s*\(\s*theta\s*\)\s*$/i);
            if (simpleTrig) {
                const fn = simpleTrig[1].toLowerCase();
                const hasAmp = isFinite(amp) && Math.abs(amp - 1) > eps;
                const hasFreq = isFinite(freq) && Math.abs(freq - 1) > eps;
                const hasShift = isFinite(tShift) && Math.abs(tShift) > eps;
                const hasRShift = isFinite(rShift) && Math.abs(rShift) > eps;

                // Prefer phase-shift form when a multiple is present: trig(k(Î¸ - a)) where a = constant/k.
                let arg = 'Î¸';
                if (hasFreq) {
                    const kStr = wrapMulCoeff(fmtEqNum(freq));
                    if (hasShift) {
                        // thetaShift is the x-shift in Î¸-units (a/k), so display directly inside k(Î¸ - shift).
                        arg = `${kStr}(Î¸ ${tShift >= 0 ? '-' : '+'} ${formatThetaExpr(Math.abs(tShift))})`;
                    } else {
                        arg = `${kStr}Î¸`;
                    }
                } else if (hasShift) {
                    arg = `Î¸ ${tShift >= 0 ? '-' : '+'} ${formatThetaExpr(Math.abs(tShift))}`;
                }

                let out = `${fn}(${arg})`;

                if (hasAmp) {
                    // Prefer "-sin(...)" over "-1 sin(...)".
                    if (Math.abs(Math.abs(amp) - 1) < 1e-10) {
                        out = (amp < 0 ? '-' : '') + out;
                    } else {
                        out = `${fmtEqNum(amp)} ${out}`;
                    }
                }
                if (hasRShift) {
                    out += ` ${rShift >= 0 ? '+' : '-'} ${fmtEqNum(Math.abs(rShift))}`;
                }
                return displayifyPiInEquation(out);
            }

            // General fallback: replace canonical 'theta' in the RHS with a linear argument.
            // IMPORTANT: thetaShift is in Î¸-units. Use k*(theta - thetaShift) so the displayed shift stays a/k.
            const hasFreq = isFinite(freq) && Math.abs(freq - 1) > eps;
            const hasShift = isFinite(tShift) && Math.abs(tShift) > eps;
            const k = hasFreq ? freq : 1;
            let argCore = 'theta';
            if (hasFreq || hasShift) {
                const kStr = wrapMulCoeff(fmtEqNum(k));
                if (Math.abs(k - 1) < eps && !hasShift) {
                    argCore = 'theta';
                } else if (!hasShift) {
                    argCore = `${kStr}*theta`;
                } else {
                    // k*(theta - tShift)
                    const sStr = formatThetaExpr(Math.abs(tShift));
                    const inner = `theta ${tShift >= 0 ? '-' : '+'} ${sStr}`;
                    argCore = (Math.abs(k - 1) < eps) ? `(${inner})` : `${kStr}*(${inner})`;
                }
            }

            // Replace both 'theta' and any literal 'Î¸' after normalization (just 'theta' now)
            // Amplitude should scale the Î¸-dependent part only.
            // Example: (sin(Î¸) + 1) with amp=Ï€ should become (Ï€ sin(Î¸)) + 1 (not Ï€ sin(Î¸) + Ï€).
            let baseAddConst = 0;
            let rhsThetaOnly = rhs;
            try {
                const n = math.parse(rhs);
                const stripped = stripOuterAdditiveConstant(n);
                baseAddConst = (stripped && isFinite(stripped.constant)) ? stripped.constant : 0;
                rhsThetaOnly = (stripped && stripped.node)
                    ? stripped.node.toString({ parenthesis: 'auto' })
                    : rhs;
            } catch (_) {
                baseAddConst = 0;
                rhsThetaOnly = rhs;
            }

            let transformed = rhsThetaOnly.replace(/\btheta\b/g, `(${argCore})`);
            const hasAmp = isFinite(amp) && Math.abs(amp - 1) > 1e-12;
            if (hasAmp) {
                transformed = `${wrapMulCoeff(fmtEqNum(amp))}*(${transformed})`;
            }
            const totalShift = (isFinite(baseAddConst) ? baseAddConst : 0) + (isFinite(rShift) ? rShift : 0);
            if (isFinite(totalShift) && Math.abs(totalShift) > 1e-12) {
                transformed = `(${transformed}) ${totalShift >= 0 ? '+' : '-'} ${fmtEqNum(Math.abs(totalShift))}`;
            }
            // Simplify; keep expanded linear form so constants combine nicely.
            try {
                let node = math.parse(transformed);
                node = math.simplify(node);
                node = factorLinearThetaInTrigArgsForDisplay(node);
                node = reorderThetaMultiplicationForDisplay(node);
                // Format with explicit numerator/denominator grouping for divisions
                let out = stringifyWithDivisionParentheses(node);
                // Convert 'theta' -> 'Î¸' for display
                out = denormalizeThetaSymbols(out);
                // Prefer implicit multiplication in the displayed equation
                out = makeImplicitMultiplicationDisplay(out);
                out = normalizePlusMinusDisplay(out);
                out = displayifyPiInEquation(out);
                return out;
            } catch (_) {
                // Fall back to basic cleanup and symbol replacement
                let out = cleanupSliderExpression(transformed);
                out = denormalizeThetaSymbols(out);
                out = makeImplicitMultiplicationDisplay(out);
                out = normalizePlusMinusDisplay(out);
                out = displayifyPiInEquation(out);
                return out;
            }
        }

        function applyEditParams() {
            const newRHS = applyEditParamsToEquation(editBaseEquation, editParams);
            equationInput.value = newRHS;
            updateEquationPretty();
            // Keep param sliders in sync with edit-mode dragging (and any other editParams changes)
            syncParamSlidersUIFromEditParams({ expandBounds: true });
            // Recompute slider bounds if frequency changed the inferred period
            updateSliderBounds();
            plotGraph();
        }

        // ===== Equation -> Params inference (keeps sliders/edit session in sync) =====
        function nearlyEqual(a, b, eps = 1e-6) {
            return (typeof a === 'number' && typeof b === 'number' && isFinite(a) && isFinite(b) && Math.abs(a - b) <= eps);
        }
        function nodeHasTheta(node) {
            try {
                if (!node || typeof node.filter !== 'function') return false;
                const deps = node.filter(n => n && n.isSymbolNode).map(n => n.name);
                return deps && deps.some(name => name === 'theta' || name === 'Î¸' || name === 'x');
            } catch (_) {
                return false;
            }
        }
        function flattenAddSub(node, sign, out) {
            if (!node) return;
            if (node.isParenthesisNode) return flattenAddSub(node.content, sign, out);
            if (node.isOperatorNode && node.op === '+' && node.args && node.args.length === 2) {
                flattenAddSub(node.args[0], sign, out);
                flattenAddSub(node.args[1], sign, out);
                return;
            }
            if (node.isOperatorNode && node.op === '-' && node.args && node.args.length === 2) {
                flattenAddSub(node.args[0], sign, out);
                flattenAddSub(node.args[1], -sign, out);
                return;
            }
            if (node.isOperatorNode && node.op === '-' && node.args && node.args.length === 1) {
                flattenAddSub(node.args[0], -sign, out);
                return;
            }
            out.push({ node, sign });
        }
        function buildSumNode(terms) {
            if (!terms || !terms.length) return math.parse('0');
            let expr = '';
            for (let i = 0; i < terms.length; i++) {
                const t = terms[i];
                const s = t.node.toString({ parenthesis: 'auto' });
                if (i === 0) {
                    expr += (t.sign < 0) ? `-(${s})` : `(${s})`;
                } else {
                    expr += (t.sign < 0) ? ` - (${s})` : ` + (${s})`;
                }
            }
            return math.parse(expr);
        }
        function stripOuterAdditiveConstant(node) {
            // Return { constant, node } where node is the theta-dependent remainder
            let terms = [];
            flattenAddSub(node, 1, terms);
            let c = 0;
            const keep = [];
            for (const t of terms) {
                const v = getConstantNumeric(t.node);
                if (v !== null && isFinite(v)) {
                    c += t.sign * v;
                } else {
                    keep.push(t);
                }
            }
            const outNode = keep.length ? buildSumNode(keep) : math.parse('0');
            return { constant: (isFinite(c) ? c : 0), node: outNode };
        }
        function stripOuterMultiplicativeConstant(node) {
            // Return { amp, node } where node is the theta-dependent remainder
            let n = node;
            if (n && n.isParenthesisNode) n = n.content;
            // unary minus
            if (n && n.isOperatorNode && n.op === '-' && n.args && n.args.length === 1) {
                const inner = n.args[0];
                if (nodeHasTheta(inner)) return { amp: -1, node: inner };
            }
            if (n && n.isOperatorNode && n.op === '*' && n.args && n.args.length >= 2) {
                let acc = 1;
                const rest = [];
                for (const a of n.args) {
                    const v = getConstantNumeric(a);
                    if (v !== null && isFinite(v)) acc *= v;
                    else rest.push(a);
                }
                if (rest.length === 1 && nodeHasTheta(rest[0]) && isFinite(acc) && Math.abs(acc - 1) > 1e-12) {
                    return { amp: acc, node: rest[0] };
                }
            }
            return { amp: 1, node: node };
        }
        function findFirstLinearThetaTransform(node) {
            let found = null;
            try {
                if (!node || typeof node.traverse !== 'function') return null;
                node.traverse(function (n) {
                    if (found) return;
                    const lf = getLinearFormInTheta(n);
                    if (lf && isFinite(lf.k) && Math.abs(lf.k) > 1e-12) {
                        found = lf;
                    }
                });
            } catch (_) {}
            return found;
        }
        function replaceMatchingLinearTheta(node, k, c) {
            try {
                return node.transform(function (n) {
                    const lf = getLinearFormInTheta(n);
                    if (lf && isFinite(lf.k) && Math.abs(lf.k) > 1e-12 && nearlyEqual(lf.k, k) && nearlyEqual(lf.c, c)) {
                        return math.parse('theta');
                    }
                    return n;
                });
            } catch (_) {
                return node;
            }
        }
        function inferEditSessionFromEquation(equation) {
            const eq = (equation || '').trim();
            const defaults = { amplitude: 1, frequency: 1, thetaShift: 0, rShift: 0 };
            if (!eq) return { ok: false, baseEq: '', params: { ...defaults } };
            try {
                const { rhs } = extractRExponentAndRHS(eq);
                const rhsRaw = rhs || eq;
                const rhsNorm = normalizeThetaSymbols(rhsRaw);
                let node = math.parse(rhsNorm);
                try { node = math.simplify(node); } catch (_) {}

                // If the whole expression is constant: treat as y-shift only.
                const wholeConst = getConstantNumeric(node);
                if (wholeConst !== null && isFinite(wholeConst)) {
                    return { ok: true, baseEq: '0', params: { ...defaults, rShift: wholeConst } };
                }

                const { constant: rShift, node: noShift } = stripOuterAdditiveConstant(node);
                const { amp, node: inner } = stripOuterMultiplicativeConstant(noShift);
                const lf = findFirstLinearThetaTransform(inner);

                let k = 1, c = 0;
                let frequency = 1;
                let thetaShift = 0;
                if (lf && isFinite(lf.k) && Math.abs(lf.k) > 1e-12) {
                    k = lf.k;
                    c = lf.c || 0;
                    frequency = Math.abs(k);
                    if (!isFinite(frequency) || frequency < 1e-12) frequency = 1;
                    thetaShift = -c / k;
                    if (!isFinite(thetaShift)) thetaShift = 0;
                }

                // Reconstruct a base equation by replacing the detected linear-theta transform back to 'theta'
                let baseNode = inner;
                if (lf) baseNode = replaceMatchingLinearTheta(baseNode, k, c);
                let baseRhsNorm = baseNode.toString({ parenthesis: 'auto' });
                baseRhsNorm = denormalizeThetaSymbols(baseRhsNorm);

                const params = {
                    amplitude: (isFinite(amp) ? amp : 1),
                    frequency,
                    thetaShift,
                    rShift: (isFinite(rShift) ? rShift : 0)
                };
                return { ok: true, baseEq: baseRhsNorm, params };
            } catch (_) {
                return { ok: false, baseEq: eq, params: { ...defaults } };
            }
        }
        function syncParamSlidersUIFromEditParams(opts = {}) {
            const expandBounds = !!opts.expandBounds;
            const ampSl = document.getElementById('ampSlider');
            const freqSl = document.getElementById('freqSlider');
            const xSl = document.getElementById('xShiftSlider');
            const ySl = document.getElementById('yShiftSlider');
            if (!ampSl || !freqSl || !xSl || !ySl) return;

            const ensureBounds = (sl, v, pad) => {
                if (!expandBounds) return;
                const min = parseFloat(sl.min);
                const max = parseFloat(sl.max);
                if (!isFinite(min) || !isFinite(max) || !isFinite(v)) return;
                if (v < min) sl.min = String(v - pad);
                if (v > max) sl.max = String(v + pad);
            };

            // Expand bounds so the slider can actually represent the current value
            ensureBounds(ampSl, editParams.amplitude, 0.5);
            ensureBounds(freqSl, editParams.frequency, 0.5);
            ensureBounds(xSl, editParams.thetaShift, Math.PI / 8);
            ensureBounds(ySl, editParams.rShift, 0.5);

            // Clamp to current slider bounds (and snap to step when step != "any")
            const snapToStep = (sl, v) => {
                const stepAttr = (sl.getAttribute('step') || '').toLowerCase();
                if (stepAttr === 'any') return v;
                const step = parseFloat(stepAttr);
                const min = parseFloat(sl.min);
                if (!isFinite(step) || step <= 0 || !isFinite(min) || !isFinite(v)) return v;
                return min + Math.round((v - min) / step) * step;
            };
            const clampTo = (sl, v) => {
                const min = parseFloat(sl.min);
                const max = parseFloat(sl.max);
                if (!isFinite(v) || !isFinite(min) || !isFinite(max)) return sl.value;
                const clamped = Math.max(min, Math.min(max, v));
                const snapped = snapToStep(sl, clamped);
                return String(Math.max(min, Math.min(max, snapped)));
            };
            ampSl.value = clampTo(ampSl, editParams.amplitude);
            freqSl.value = clampTo(freqSl, editParams.frequency);
            xSl.value = clampTo(xSl, editParams.thetaShift);
            ySl.value = clampTo(ySl, editParams.rShift);

            updateParamBoundsLabels();
            updateParamLabels();
        }

        // Simplify inferred shifts when it's mathematically safe.
        // In practice this helps collapse equivalent trig shifts like 2Ï€ -> 0 after users edit the equation.
        function simplifyInferredShiftsIfPossible(equation, params) {
            const out = { ...(params || {}) };
            const eps = 1e-9;
            if (isFinite(out.thetaShift) && Math.abs(out.thetaShift) < eps) out.thetaShift = 0;
            if (isFinite(out.rShift) && Math.abs(out.rShift) < eps) out.rShift = 0;

            try {
                const eq = (equation || '').trim();
                if (!eq) return out;
                const { rhs } = extractRExponentAndRHS(eq);
                const rhsRaw = (rhs || eq);
                const rhsNorm = normalizeThetaSymbols(rhsRaw);

                // Only attempt modulo simplification for purely trig-periodic theta dependence.
                const hasTrig = /\b(sin|cos|tan|sec|csc|cot)\b/i.test(rhsNorm);
                if (!hasTrig) return out;

                // Verify there is no Î¸ outside a trig() argument; otherwise a modulo shift could change the function.
                let node = null;
                try { node = math.parse(rhsNorm); } catch (_) { node = null; }
                if (!node) return out;
                const trigNames = new Set(['sin', 'cos', 'tan', 'sec', 'csc', 'cot']);
                const hasThetaOutsideTrigArg = (function walk(n, inTrigArg) {
                    if (!n) return false;
                    if (n.isParenthesisNode) return walk(n.content, inTrigArg);
                    if (n.isSymbolNode && (n.name === 'theta' || n.name === 'Î¸' || n.name === 'x')) {
                        return !inTrigArg;
                    }
                    if (n.isFunctionNode) {
                        const fnName =
                            (n.fn && typeof n.fn.name === 'string' ? n.fn.name :
                             (typeof n.name === 'string' ? n.name : '')).toLowerCase();
                        const nextInTrigArg = inTrigArg || trigNames.has(fnName);
                        const args = Array.isArray(n.args) ? n.args : [];
                        for (const a of args) {
                            if (walk(a, nextInTrigArg)) return true;
                        }
                        return false;
                    }
                    if (Array.isArray(n.args)) {
                        for (const a of n.args) {
                            if (walk(a, inTrigArg)) return true;
                        }
                    }
                    return false;
                })(node, false);
                if (hasThetaOutsideTrigArg) return out;

                const perInfo = (typeof detectPeriodicity === 'function') ? detectPeriodicity(rhsRaw) : null;
                const period = perInfo && isFinite(perInfo.period) ? Math.abs(perInfo.period) : null;
                if (!period || period < 1e-9) return out;

                if (isFinite(out.thetaShift)) {
                    // Choose the "nicest" equivalent shift among t + n*period.
                    // We prefer clean integers / Ï€-fractions over smaller-but-ugly decimals.
                    const t0 = out.thetaShift;
                    const candidates = [];
                    for (let n = -3; n <= 3; n++) {
                        const t = t0 + n * period;
                        if (isFinite(t)) candidates.push(t);
                    }
                    const score = (t) => {
                        if (!isFinite(t)) return Infinity;
                        if (Math.abs(t) < eps) return 0; // always prefer 0 when it's available
                        // Prefer Ï€ expressions if they exist (very readable)
                        let piStr = '';
                        try { piStr = formatThetaExpr(Math.abs(t)); } catch (_) { piStr = ''; }
                        const hasPi = (typeof piStr === 'string' && /\bpi\b/i.test(piStr));
                        // Use the equation-number formatter for display length
                        const s = fmtEqNum(Math.abs(t));
                        const len = String(s).length;
                        // Penalize ugly decimals; lightly penalize magnitude to avoid giant numbers.
                        return (hasPi ? 0.5 : len) + Math.abs(t) * 0.001;
                    };
                    let best = t0;
                    let bestScore = score(t0);
                    for (const t of candidates) {
                        const sc = score(t);
                        if (sc < bestScore - 1e-12) { best = t; bestScore = sc; }
                    }
                    if (Math.abs(best) < eps) best = 0;
                    out.thetaShift = best;
                }
            } catch (_) {}

            return out;
        }
        function syncParamsFromEquationInput(opts = {}) {
            const expandBounds = !!opts.expandBounds;
            const simplifyShifts = !!opts.simplifyShifts;
            const eq = (equationInput.value || '').trim();
            if (!eq) return;
            const inferred = inferEditSessionFromEquation(eq);
            if (inferred && inferred.ok) {
                if (simplifyShifts) {
                    inferred.params = simplifyInferredShiftsIfPossible(eq, inferred.params);
                }
                editParams = inferred.params;
                editBaseEquation = (inferred.baseEq || '').trim() || eq;
                // Treat typed equation as a valid "base + params" session so sliders don't compound transforms
                sliderSessionActive = true;
                syncParamSlidersUIFromEditParams({ expandBounds });
            } else {
                sliderSessionActive = false;
                editBaseEquation = eq;
                editParams = { amplitude: 1, frequency: 1, thetaShift: 0, rShift: 0 };
                if (typeof resetParamSlidersUI === 'function') resetParamSlidersUI();
            }
        }

        function evaluateRAtTheta(theta) {
            try {
                const { exponent: effExp, rhs } = extractRExponentAndRHS(equationInput.value || '');
                const expr = rhs
                    .replace(/\btheta\b/g, `(${theta})`)
                    .replace(/Î¸/g, `(${theta})`)
                    .replace(/\bx\b/g, `(${theta})`);
                let rBase = math.evaluate(expr);
                if (typeof rBase === 'object' && rBase && rBase.re !== undefined) rBase = rBase.re;
                let r = applyExponentToValue(rBase, effExp);
                if (typeof r === 'object' && r && r.re !== undefined) r = r.re;
                return (isFinite(r) ? r : NaN);
            } catch (_) {
                return NaN;
            }
        }

        function cartesianMouseToWorld(e) {
            const rect = cartesianCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const padding = 60;
            const plotWidth = cartesianCanvas.width - 2 * padding;
            const plotHeight = cartesianCanvas.height - 2 * padding;
            if (mouseX < padding || mouseX > cartesianCanvas.width - padding ||
                mouseY < padding || mouseY > cartesianCanvas.height - padding) {
                return null;
            }
            const baseRangeView = 10 / cartesianZoom;
            const xMin = cartesianCenterX - baseRangeView;
            const xMax = cartesianCenterX + baseRangeView;
            const yMin = cartesianCenterY - baseRangeView;
            const yMax = cartesianCenterY + baseRangeView;
            const theta = xMin + ((mouseX - padding) / plotWidth) * (xMax - xMin);
            const r = yMax - ((mouseY - padding) / plotHeight) * (yMax - yMin);
            return { theta, r };
        }

        function mapAngleToThetaInDomain(angle, thetaMin, thetaMax, refTheta) {
            const twoPi = 2 * Math.PI;
            if (!isFinite(angle) || !isFinite(thetaMin) || !isFinite(thetaMax) || thetaMin === thetaMax) return angle;
            const min = Math.min(thetaMin, thetaMax);
            const max = Math.max(thetaMin, thetaMax);
            // Pick the equivalent angle + 2Ï€k closest to the current slider theta to avoid jumpiness.
            let theta = angle + twoPi * Math.round(((isFinite(refTheta) ? refTheta : 0) - angle) / twoPi);
            // If still outside, shift by whole turns towards the interval.
            while (theta < min) theta += twoPi;
            while (theta > max) theta -= twoPi;
            // Final clamp if the interval is smaller than 2Ï€ or doesn't contain any equivalent angle.
            return clamp(min, max, theta);
        }

        function polarMouseToWorld(e) {
            if (!polarCanvas) return null;
            const rect = polarCanvas.getBoundingClientRect();
            if (!rect.width || !rect.height) return null;

            // Convert CSS pixel coords -> canvas pixel coords (robust if canvas is scaled)
            const cssX = e.clientX - rect.left;
            const cssY = e.clientY - rect.top;
            const scaleX = polarCanvas.width / rect.width;
            const scaleY = polarCanvas.height / rect.height;
            const x = cssX * scaleX;
            const y = cssY * scaleY;

            const dx = x - lastPolarState.centerX;
            const dy = lastPolarState.centerY - y; // invert Y
            const distPx = Math.hypot(dx, dy);
            if (!isFinite(distPx) || !isFinite(lastPolarState.radiusPx) || lastPolarState.radiusPx <= 0) return null;

            // Only show coordinates inside the polar plot circle
            if (distPx > lastPolarState.radiusPx) return null;

            let angle = Math.atan2(dy, dx);
            if (angle < 0) angle += 2 * Math.PI;

            // Map the visible angle to the slider's theta domain (supports ranges like [-Ï€, Ï€], [0, 4Ï€], etc.)
            let theta = angle;
            const slider = document.getElementById('thetaSlider');
            if (slider) {
                const actualMin = parseFloat(slider.dataset.actualMin || '0');
                const actualMax = parseFloat(slider.dataset.actualMax || (2 * Math.PI).toString());
                theta = mapAngleToThetaInDomain(angle, actualMin, actualMax, sliderTheta);
            }

            const r = (distPx / lastPolarState.radiusPx) * lastPolarState.maxR;
            return { theta, r };
        }

        function updateSliderFromTheta(theta) {
            const slider = document.getElementById('thetaSlider');
            if (!slider) return;
            const actualMin = parseFloat(slider.dataset.actualMin || '0');
            const actualMax = parseFloat(slider.dataset.actualMax || (2 * Math.PI).toString());
            const t = clamp(actualMin, actualMax, theta);
            sliderTheta = round2(t);
            const pct = ((sliderTheta - actualMin) / (actualMax - actualMin)) * 100;
            slider.value = String(pct);
            document.getElementById('sliderValue').textContent = `Î¸ = ${formatTheta(sliderTheta)}`;
        }

        function onCartesianHover(e) {
            if (interactionMode !== 'view') { hideCoordTooltip(); return; }
            const c = cartesianMouseToWorld(e);
            if (!c) { hideCoordTooltip(); return; }
            updateSliderFromTheta(c.theta);
            const r = evaluateRAtTheta(sliderTheta);
            const msg = `Î¸ = ${formatTheta(sliderTheta)}, r = ${isFinite(r) ? r.toFixed(2) : 'â€”'}`;
            showCoordTooltip(msg, e.clientX, e.clientY);
            plotGraph();
        }
        function onCartesianLeave() {
            hideCoordTooltip();
            if (interactionMode === 'edit' && cartesianCanvas) {
                // Default back to move (plus with arrows) when not over the graph
                cartesianCanvas.style.cursor = 'move';
            }
        }
        cartesianCanvas.addEventListener('mousemove', onCartesianHover);
        cartesianCanvas.addEventListener('mouseleave', onCartesianLeave);

        function onPolarHover(e) {
            if (interactionMode !== 'view') { hideCoordTooltip(); return; }
            const c = polarMouseToWorld(e);
            if (!c) { hideCoordTooltip(); return; }
            updateSliderFromTheta(c.theta);
            const msg = `Î¸ = ${formatTheta(sliderTheta)}, r = ${isFinite(c.r) ? c.r.toFixed(2) : 'â€”'}`;
            showCoordTooltip(msg, e.clientX, e.clientY);
            plotGraph();
        }
        function onPolarLeave() { hideCoordTooltip(); }
        polarCanvas.addEventListener('mousemove', onPolarHover);
        polarCanvas.addEventListener('mouseleave', onPolarLeave);

        // drawEditOverlay function removed - no longer showing arrows when shifting

                // Enhance edit mode mouse handling to update overlay and snapping
        document.addEventListener('mousemove', (e) => {
            if (interactionMode === 'edit') {
                // Update cursor based on adjust mode
                if (cartesianCanvas) {
                    const rect = cartesianCanvas.getBoundingClientRect();
                    const inside =
                        e.clientX >= rect.left && e.clientX <= rect.right &&
                        e.clientY >= rect.top && e.clientY <= rect.bottom;
                    if (inside) {
                        // While actively dragging, show appropriate cursor
                        if (isEditTranslating && editAdjustMode === 'shift') {
                            cartesianCanvas.style.cursor = 'move';
                        } else if (isEditAdjustingAmplitude && editAdjustMode === 'amplitude') {
                            cartesianCanvas.style.cursor = 'ns-resize';
                        } else if (isEditAdjustingFrequency && editAdjustMode === 'frequency') {
                            cartesianCanvas.style.cursor = 'ew-resize';
                        } else {
                            // Use cursor based on selected adjust mode
                            if (editAdjustMode === 'amplitude') {
                                cartesianCanvas.style.cursor = 'ns-resize';
                            } else if (editAdjustMode === 'frequency') {
                                cartesianCanvas.style.cursor = 'ew-resize';
                            } else {
                                // Shift mode: move cursor (cross with arrows)
                                cartesianCanvas.style.cursor = 'move';
                            }
                        }
                    }
                }
                // Update polar canvas cursor as well
                if (polarCanvas) {
                    const rect = polarCanvas.getBoundingClientRect();
                    const inside =
                        e.clientX >= rect.left && e.clientX <= rect.right &&
                        e.clientY >= rect.top && e.clientY <= rect.bottom;
                    if (inside) {
                        // While actively dragging, show appropriate cursor
                        if (isEditTranslating && editAdjustMode === 'shift') {
                            polarCanvas.style.cursor = 'move';
                        } else if (isEditAdjustingAmplitude && editAdjustMode === 'amplitude') {
                            polarCanvas.style.cursor = 'ns-resize';
                        } else if (isEditAdjustingFrequency && editAdjustMode === 'frequency') {
                            polarCanvas.style.cursor = 'ew-resize';
                        } else {
                            // Use cursor based on selected adjust mode
                            if (editAdjustMode === 'amplitude') {
                                polarCanvas.style.cursor = 'ns-resize';
                            } else if (editAdjustMode === 'frequency') {
                                polarCanvas.style.cursor = 'ew-resize';
                            } else {
                                // Shift mode: move cursor (cross with arrows)
                                polarCanvas.style.cursor = 'move';
                            }
                        }
                    }
                }
                const c = cartesianMouseToWorld(e);
                if (c) lastEditMouseWorld = c;
                if (isEditTranslating && editStart && c && editAdjustMode === 'shift') {
                    const dTheta = c.theta - editStart.theta0;
                    const dR = c.r - editStart.r0;
                    editParams.thetaShift = snapToIncrement(editStart.thetaShift + dTheta, 0.01);
                    editParams.rShift = snapToIncrement(editStart.rShift + dR, 0.01);
                    applyEditParams();
                } else if (isEditAdjustingAmplitude && editStart && editAdjustMode === 'amplitude') {
                    // Lock to vertical movement only - calculate amplitude change from Y movement
                    const deltaY = e.clientY - editStart.mouseY;
                    // Convert pixel movement to amplitude change
                    // Negative deltaY (moving up) increases amplitude, positive (moving down) decreases
                    // Scale factor: ~0.02 per pixel for increased sensitivity
                    const amplitudeDelta = -deltaY * 0.02;
                    const newAmplitude = editStart.amplitude + amplitudeDelta;
                    // Allow negative amplitude
                    editParams.amplitude = snapToIncrement(newAmplitude, 0.01);
                    applyEditParams();
                } else if (isEditAdjustingFrequency && editStart && editAdjustMode === 'frequency') {
                    // Lock to horizontal movement only - calculate frequency change from X movement
                    const deltaX = e.clientX - editStart.mouseX;
                    // Convert pixel movement to frequency change
                    // Positive deltaX (moving right) increases frequency, negative (moving left) decreases
                    // Scale factor: ~0.02 per pixel for increased sensitivity
                    const frequencyDelta = deltaX * 0.02;
                    const newFrequency = editStart.frequency + frequencyDelta;
                    // Clamp frequency to reasonable bounds (0.05 to 20)
                    const clamped = Math.max(0.05, Math.min(20, newFrequency));
                    editParams.frequency = Math.max(0.05, Math.min(20, snapToIncrement(clamped, 0.01)));
                    applyEditParams();
                }
            }
        }, true);

        // Slider bound editors (min/max input boxes flanking the slider)
        function attachSliderLabelEditors() {
            const slider = document.getElementById('thetaSlider');
            const minLabel = document.getElementById('sliderMinLabel');
            const maxLabel = document.getElementById('sliderMaxLabel');
            if (!slider || !minLabel || !maxLabel) return;

            const restoreDisplay = (which) => {
                const actualMin = parseFloat(slider.dataset.actualMin || '0');
                const actualMax = parseFloat(slider.dataset.actualMax || (2 * Math.PI).toString());
                if (which === 'min') minLabel.value = `${formatTheta(actualMin)}`;
                else maxLabel.value = `${formatTheta(actualMax)}`;
            };

            const applyValue = (which, raw) => {
                const text = (raw || '').trim();
                if (text === '') {
                    if (which === 'min') sliderMin = null;
                    else sliderMax = null;
                    updateSliderBounds();
                    plotGraph();
                    return;
                }

                const num = parseThetaExpression(text);
                if (num === null || !isFinite(num)) {
                    restoreDisplay(which);
                    return;
                }

                if (which === 'min') sliderMin = num;
                else sliderMax = num;

                // Ensure min < max when both are set
                if (sliderMin !== null && sliderMax !== null && sliderMin >= sliderMax) {
                    if (which === 'min') {
                        sliderMax = sliderMin + Math.max(Math.abs(sliderMin) * 0.1, 0.1);
                    } else {
                        sliderMin = sliderMax - Math.max(Math.abs(sliderMax) * 0.1, 0.1);
                    }
                }

                updateSliderBounds();
                plotGraph();
            };

            const wire = (el, which) => {
                el.addEventListener('focus', () => {
                    // Select all to make quick overwrite easy
                    try { el.select(); } catch (_) {}
                });
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        applyValue(which, el.value);
                        el.blur();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        restoreDisplay(which);
                        el.blur();
                    }
                });
                el.addEventListener('blur', () => applyValue(which, el.value));
            };

            wire(minLabel, 'min');
            wire(maxLabel, 'max');
        }

        // Allow dblclick editing of the Î¸ value in the center label
        function attachThetaValueEditor() {
            const label = document.getElementById('sliderValue');
            const slider = document.getElementById('thetaSlider');
            if (!label || !slider) return;
            label.title = 'Double-click to set Î¸ exactly';
            label.addEventListener('dblclick', () => {
                // Build inline editor: "Î¸ = [input]"
                const container = document.createElement('span');
                const prefix = document.createElement('span');
                prefix.textContent = 'Î¸ = ';
                const input = document.createElement('input');
                input.type = 'text';
                input.value = formatTheta(sliderTheta);
                input.style.width = '110px';
                input.style.fontSize = '1rem';
                input.style.padding = '2px 6px';
                input.style.borderRadius = '6px';
                input.style.border = '1px solid rgba(255,255,255,0.6)';
                input.style.background = 'rgba(255,255,255,0.95)';
                input.style.color = '#111827';
                container.appendChild(prefix);
                container.appendChild(input);
                // Swap contents
                label.textContent = '';
                label.appendChild(container);
                input.focus();
                input.select();
                const finish = (apply) => {
                    if (apply) {
                        const raw = input.value.trim();
                        const val = parseThetaExpression(raw);
                        if (val !== null && isFinite(val)) {
                            const actualMin = parseFloat(slider.dataset.actualMin || '0');
                            const actualMax = parseFloat(slider.dataset.actualMax || (2 * Math.PI).toString());
                            // Clamp within range
                            const theta = Math.max(actualMin, Math.min(actualMax, val));
                            sliderTheta = theta;
                            // Update slider thumb position
                            const pct = ((theta - actualMin) / (actualMax - actualMin)) * 100;
                            slider.value = String(pct);
                            label.textContent = `Î¸ = ${formatTheta(theta)}`;
                            plotGraph();
                            return;
                        }
                    }
                    // Fallback restore without changes
                    label.textContent = `Î¸ = ${formatTheta(sliderTheta)}`;
                };
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') { e.preventDefault(); finish(true); }
                    else if (e.key === 'Escape') { e.preventDefault(); finish(false); }
                });
                input.addEventListener('blur', () => finish(true));
            });
        }

        // Parse input like "pi", "2*pi", "1.5Ï€", "Ï€/2", "3.14"
        function parseThetaExpression(text) {
            if (!text) return null;
            try {
                // Normalize Ï€ and pi to mathjs 'pi'
                let expr = text.replace(/Ï€/gi, 'pi').replace(/PI/gi, 'pi');
                // Convert superscripts back to ^digits (e.g., Ï€Â² -> pi^2)
                expr = expr.replace(/([â°Â¹Â²Â³â´âµâ¶â·â¸â¹âºâ»]+)/g, (m) => {
                    const map = { 'â°':'0','Â¹':'1','Â²':'2','Â³':'3','â´':'4','âµ':'5','â¶':'6','â·':'7','â¸':'8','â¹':'9','âº':'+','â»':'-' };
                    let digits = '';
                    for (const ch of m) digits += (map[ch] || '');
                    return digits ? '^' + digits : '';
                });
                // Map pretty root back
                expr = expr.replace(/âˆš/g, 'sqrt');
                // Normalize division symbol
                expr = expr.replace(/Ã·/g, '/');
                // Allow implicit multiplication like "2pi"
                expr = expr.replace(/(\d)\s*pi\b/gi, '$1*pi');
                const val = math.evaluate(expr);
                const num = typeof val === 'object' && val && val.re !== undefined ? val.re : val;
                return typeof num === 'number' ? num : null;
            } catch (e) {
                const direct = parseFloat(text);
                return isNaN(direct) ? null : direct;
            }
        }

        // Parse numeric input like "pi", "2*pi", "sqrt(2)", "3/4", "1.25"
        function parseNumberExpression(text) {
            if (!text) return null;
            try {
                let expr = text.replace(/Ï€/gi, 'pi').replace(/PI/gi, 'pi');
                expr = expr.replace(/âˆš/g, 'sqrt').replace(/Ã·/g, '/');
                const val = math.evaluate(expr);
                const num = typeof val === 'object' && val && val.re !== undefined ? val.re : val;
                return typeof num === 'number' ? num : null;
            } catch (_) {
                const direct = parseFloat(text);
                return isNaN(direct) ? null : direct;
            }
        }

        function prettifyPi(text) {
            const raw = (text || '').trim();
            if (!raw) return raw;
            // Prefer the Ï€ symbol in UI if the user used pi/Ï€
            let out = raw.replace(/\bpi\b/gi, 'Ï€');
            // Make common "2*pi" look like "2Ï€" (keep other '*' as-is)
            out = out.replace(/(\d)\s*\*\s*Ï€/g, '$1Ï€');
            out = out.replace(/Ï€\s*\*\s*(\d)/g, 'Ï€$1');
            return out;
        }
        function displayifyPiInEquation(s) {
            if (!s) return s;
            // Convert 'pi' tokens to Ï€ for the visible equation input.
            // Avoid identifiers like 'spin' by requiring non-letter boundaries.
            return String(s).replace(/(^|[^A-Za-z])pi(?=[^A-Za-z]|$)/gi, (_m, p1) => `${p1}Ï€`);
        }
        function setBoundDisplay(el, display) {
            if (!el) return;
            if (el.tagName === 'INPUT') el.value = display;
            else el.textContent = display;
        }
        function getBoundDisplay(el) {
            if (!el) return '';
            return el.tagName === 'INPUT' ? (el.value || '') : (el.textContent || '');
        }
        
        // ===== Parameter Sliders (Amplitude, Frequency, Shifts) =====
        function updateParamLabels() {
            const ampIn = document.getElementById('ampInput');
            const freqIn = document.getElementById('freqInput');
            const xIn = document.getElementById('xShiftInput');
            const yIn = document.getElementById('yShiftInput');
            const eps = 1e-9;
            if (ampIn) {
                if (document.activeElement === ampIn) return;
                const raw = (ampIn.dataset.exprDisplay || '').trim();
                const parsed = raw ? parseNumberExpression(raw) : null;
                if (raw && parsed !== null && isFinite(parsed) && isFinite(editParams.amplitude) && Math.abs(parsed - editParams.amplitude) <= eps) {
                    ampIn.value = raw;
                } else {
                    ampIn.dataset.exprDisplay = '';
                    ampIn.value = isFinite(editParams.amplitude) ? String(editParams.amplitude) : '';
                }
            }
            if (freqIn) {
                if (document.activeElement === freqIn) return;
                const raw = (freqIn.dataset.exprDisplay || '').trim();
                const parsed = raw ? parseNumberExpression(raw) : null;
                if (raw && parsed !== null && isFinite(parsed) && isFinite(editParams.frequency) && Math.abs(parsed - editParams.frequency) <= eps) {
                    freqIn.value = raw;
                } else {
                    freqIn.dataset.exprDisplay = '';
                    freqIn.value = isFinite(editParams.frequency) ? String(editParams.frequency) : '';
                }
            }
            if (xIn && document.activeElement !== xIn) xIn.value = formatTheta(editParams.thetaShift);
            if (yIn) {
                if (document.activeElement === yIn) return;
                const raw = (yIn.dataset.exprDisplay || '').trim();
                const parsed = raw ? parseNumberExpression(raw) : null;
                if (raw && parsed !== null && isFinite(parsed) && isFinite(editParams.rShift) && Math.abs(parsed - editParams.rShift) <= eps) {
                    yIn.value = raw;
                } else {
                    yIn.dataset.exprDisplay = '';
                    yIn.value = isFinite(editParams.rShift) ? String(editParams.rShift) : '';
                }
            }
        }
        function resetParamSlidersUI() {
            const amp = document.getElementById('ampSlider');
            const freq = document.getElementById('freqSlider');
            const xs = document.getElementById('xShiftSlider');
            const ys = document.getElementById('yShiftSlider');
            if (amp) amp.value = '1';
            if (freq) freq.value = '1';
            if (xs) xs.value = '0';
            if (ys) ys.value = '0';
            updateParamLabels();
            updateParamBoundsLabels();
        }
        function onParamSliderChange(source = 'slider') {
            const amp = document.getElementById('ampSlider');
            const freq = document.getElementById('freqSlider');
            const xs = document.getElementById('xShiftSlider');
            const ys = document.getElementById('yShiftSlider');
            if (!amp || !freq || !xs || !ys) return;
            const snapToStep = (sl, v) => {
                const stepAttr = (sl.getAttribute('step') || '').toLowerCase();
                if (stepAttr === 'any') return v;
                const step = parseFloat(stepAttr);
                const min = parseFloat(sl.min);
                if (!isFinite(step) || step <= 0 || !isFinite(min) || !isFinite(v)) return v;
                return min + Math.round((v - min) / step) * step;
            };
            if (!sliderSessionActive) {
                editBaseEquation = (equationInput.value || '').trim();
                sliderSessionActive = true;
            }
            const quantize = (v) => (source === 'slider' ? round2(v) : v);
            const a = quantize(snapToStep(amp, parseFloat(amp.value)));
            const f = quantize(snapToStep(freq, parseFloat(freq.value)));
            const t = quantize(snapToStep(xs, parseFloat(xs.value)));
            const r = quantize(snapToStep(ys, parseFloat(ys.value)));
            if (isFinite(a)) amp.value = String(a);
            if (isFinite(f)) freq.value = String(f);
            if (isFinite(t)) xs.value = String(t);
            if (isFinite(r)) ys.value = String(r);
            editParams.amplitude = a;
            editParams.frequency = f;
            editParams.thetaShift = t;
            editParams.rShift = r;
            updateParamLabels();
            updatingEquationFromSliders = true;
            applyEditParams();
            updatingEquationFromSliders = false;
        }
        function updateParamBoundsLabels() {
            const amp = document.getElementById('ampSlider');
            const freq = document.getElementById('freqSlider');
            const xs = document.getElementById('xShiftSlider');
            const ys = document.getElementById('yShiftSlider');
            const ampMin = document.getElementById('ampMinLabel');
            const ampMax = document.getElementById('ampMaxLabel');
            const freqMin = document.getElementById('freqMinLabel');
            const freqMax = document.getElementById('freqMaxLabel');
            const xsMin = document.getElementById('xShiftMinLabel');
            const xsMax = document.getElementById('xShiftMaxLabel');
            const ysMin = document.getElementById('yShiftMinLabel');
            const ysMax = document.getElementById('yShiftMaxLabel');
            const eps = 1e-9;
            const maybeUpdateInput = (el, num, formatter, parser) => {
                if (!el) return;
                if (el.tagName !== 'INPUT') {
                    setBoundDisplay(el, formatter(num));
                    return;
                }
                // If the user is actively typing, don't clobber their input with formatted numbers.
                if (document.activeElement === el) return;
                const raw = (el.dataset.exprDisplay || '').trim();
                const parsed = raw ? parser(raw) : null;
                if (raw && parsed !== null && isFinite(parsed) && isFinite(num) && Math.abs(parsed - num) <= eps) {
                    // Keep user's expression display (e.g., Ï€) as long as it still matches the numeric bound.
                    el.value = raw;
                } else {
                    el.dataset.exprDisplay = '';
                    el.value = formatter(num);
                }
            };
            if (amp && ampMin) maybeUpdateInput(ampMin, parseFloat(amp.min), (n) => Number(n).toFixed(2), parseNumberExpression);
            if (amp && ampMax) maybeUpdateInput(ampMax, parseFloat(amp.max), (n) => Number(n).toFixed(2), parseNumberExpression);
            if (freq && freqMin) maybeUpdateInput(freqMin, parseFloat(freq.min), (n) => Number(n).toFixed(2), parseNumberExpression);
            if (freq && freqMax) maybeUpdateInput(freqMax, parseFloat(freq.max), (n) => Number(n).toFixed(2), parseNumberExpression);
            if (xs && xsMin) maybeUpdateInput(xsMin, parseFloat(xs.min), (n) => formatTheta(Number(n)), parseThetaExpression);
            if (xs && xsMax) maybeUpdateInput(xsMax, parseFloat(xs.max), (n) => formatTheta(Number(n)), parseThetaExpression);
            if (ys && ysMin) maybeUpdateInput(ysMin, parseFloat(ys.min), (n) => Number(n).toFixed(2), parseNumberExpression);
            if (ys && ysMax) maybeUpdateInput(ysMax, parseFloat(ys.max), (n) => Number(n).toFixed(2), parseNumberExpression);
        }
        function attachParamBoundInputs() {
            const binds = [
                ['amp', 'min'], ['amp', 'max'],
                ['freq', 'min'], ['freq', 'max'],
                ['xShift', 'min'], ['xShift', 'max'],
                ['yShift', 'min'], ['yShift', 'max'],
            ];
            const apply = (kind, which) => {
                const slider = document.getElementById(kind + 'Slider');
                const el = document.getElementById(kind + (which === 'min' ? 'MinLabel' : 'MaxLabel'));
                if (!slider || !el || el.tagName !== 'INPUT') return;
                const isTheta = (kind === 'xShift');
                const raw = (el.value || '').trim();
                if (!raw) { updateParamBoundsLabels(); return; }
                const parser = isTheta ? parseThetaExpression : parseNumberExpression;
                const parsed = parser(raw);
                if (parsed === null || !isFinite(parsed)) { updateParamBoundsLabels(); return; }

                // Commit numeric bound to slider
                if (which === 'min') {
                    slider.min = String(parsed);
                    if (parseFloat(slider.value) < parsed) slider.value = String(parsed);
                } else {
                    slider.max = String(parsed);
                    if (parseFloat(slider.value) > parsed) slider.value = String(parsed);
                }
                // Ensure min < max
                let minVal = parseFloat(slider.min);
                let maxVal = parseFloat(slider.max);
                if (minVal >= maxVal) {
                    const bump = isTheta ? (Math.PI / 180) : 0.01;
                    if (which === 'min') {
                        maxVal = minVal + bump;
                        slider.max = String(maxVal);
                    } else {
                        minVal = maxVal - bump;
                        slider.min = String(minVal);
                    }
                }

                // Preserve Ï€ display if the user used pi/Ï€
                const disp = prettifyPi(raw);
                if (/Ï€/i.test(disp)) el.dataset.exprDisplay = disp;
                else el.dataset.exprDisplay = ''; // allow numeric formatting
                el.value = (el.dataset.exprDisplay || el.value);

                onParamSliderChange('direct');
                updateParamBoundsLabels();
            };
            for (const [kind, which] of binds) {
                const el = document.getElementById(kind + (which === 'min' ? 'MinLabel' : 'MaxLabel'));
                if (!el || el.tagName !== 'INPUT') continue;
                el.addEventListener('focus', () => { try { el.select(); } catch (_) {} });
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') { e.preventDefault(); apply(kind, which); el.blur(); }
                    else if (e.key === 'Escape') { e.preventDefault(); updateParamBoundsLabels(); el.blur(); }
                });
                el.addEventListener('blur', () => apply(kind, which));
            }
        }
        function attachParamDirectInputs() {
            const ampIn = document.getElementById('ampInput');
            const freqIn = document.getElementById('freqInput');
            const xIn = document.getElementById('xShiftInput');
            const yIn = document.getElementById('yShiftInput');
            const ampSl = document.getElementById('ampSlider');
            const freqSl = document.getElementById('freqSlider');
            const xSl = document.getElementById('xShiftSlider');
            const ySl = document.getElementById('yShiftSlider');
            const wireExpr = (inEl, slEl, parser, prettify) => {
                if (!inEl || !slEl) return;
                inEl.addEventListener('input', () => {
                    // If the user types pi/Ï€, prefer showing the Ï€ symbol immediately (and never overwrite with decimals).
                    const prettyNow = prettify(inEl.value || '');
                    if (prettyNow !== (inEl.value || '')) inEl.value = prettyNow;
                    const v = parser((inEl.value || '').trim());
                    if (v !== null && isFinite(v)) {
                        slEl.value = String(Math.max(parseFloat(slEl.min), Math.min(parseFloat(slEl.max), v)));
                        onParamSliderChange('direct');
                    }
                });
                inEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const pretty = prettify(inEl.value || '');
                        if (/Ï€/i.test(pretty)) inEl.dataset.exprDisplay = pretty;
                        else inEl.dataset.exprDisplay = '';
                        if (inEl.dataset.exprDisplay) inEl.value = inEl.dataset.exprDisplay;
                        inEl.blur();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        inEl.dataset.exprDisplay = '';
                        updateParamLabels();
                        inEl.blur();
                    }
                });
                inEl.addEventListener('blur', () => {
                    const pretty = prettify(inEl.value || '');
                    if (/Ï€/i.test(pretty)) inEl.dataset.exprDisplay = pretty;
                    else inEl.dataset.exprDisplay = '';
                    if (inEl.dataset.exprDisplay) inEl.value = inEl.dataset.exprDisplay;
                });
            };
            wireExpr(ampIn, ampSl, parseNumberExpression, prettifyPi);
            wireExpr(freqIn, freqSl, parseNumberExpression, prettifyPi);
            if (xIn && xSl) xIn.addEventListener('input', () => {
                const raw = xIn.value.trim();
                const v = parseThetaExpression(raw);
                if (v !== null && isFinite(v)) {
                    xSl.value = String(Math.max(parseFloat(xSl.min), Math.min(parseFloat(xSl.max), v)));
                    onParamSliderChange('direct');
                }
            });
            wireExpr(yIn, ySl, parseNumberExpression, prettifyPi);
        }
        function initParamSliders() {
            const amp = document.getElementById('ampSlider');
            const freq = document.getElementById('freqSlider');
            const xs = document.getElementById('xShiftSlider');
            const ys = document.getElementById('yShiftSlider');
            const resetBtn = document.getElementById('resetParamsBtn');
            if (amp) amp.addEventListener('input', () => onParamSliderChange('slider'));
            if (freq) freq.addEventListener('input', () => onParamSliderChange('slider'));
            if (xs) xs.addEventListener('input', () => onParamSliderChange('slider'));
            if (ys) ys.addEventListener('input', () => onParamSliderChange('slider'));
            attachParamBoundInputs();
            attachParamDirectInputs();
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    editParams = { amplitude: 1, frequency: 1, thetaShift: 0, rShift: 0 };
                    resetParamSlidersUI();
                    if (!sliderSessionActive) {
                        editBaseEquation = (equationInput.value || '').trim();
                        sliderSessionActive = true;
                    }
                    updatingEquationFromSliders = true;
                    applyEditParams();
                    updatingEquationFromSliders = false;
                });
            }
            // Initialize label values
            resetParamSlidersUI();
            updateParamBoundsLabels();
        }

        function initGraphResetButton() {
            const btn = document.getElementById('resetGraphsBtn');
            if (!btn) return;
            btn.addEventListener('click', resetBothGraphs);
        }
        function setupToggles() {
            const ids = ['toggleTheta','toggleRadius','toggleAmp','toggleFreq','toggleShifts','toggleColorRadius'];
            for (const id of ids) {
                const el = document.getElementById(id);
                if (!el) continue;
                el.addEventListener('change', () => {
                    updateEquationPretty();
                    updateEquationOverlay();
                    plotGraph();
                });
            }
        }

        // Plot default equation on load
        window.addEventListener('load', () => {
            setupRangeInputListeners();
            setupSlider();
            initParamSliders();
            setupToggles();
            initBottomTabs();
            initGraphResetButton();
            initRPrefix();
            updateCanvasCursor();
            // Keep overlay synced on load
            updateEquationOverlay();
            // Keep param sliders synced to whatever equation is loaded by default
            syncParamsFromEquationInput({ expandBounds: false });
            const equation = equationInput.value.trim();
            if (equation) {
                autoSetRange(equation);
            }
            updateSliderBounds();
            updateEquationPretty();
            plotGraph();
            if (!defaultCartesianBounds) {
                rememberDefaultCartesianView(true);
            }
            if (defaultPolarZoom === null) {
                rememberDefaultPolarZoom(true);
            }
        });
        
        // Also setup listeners immediately if DOM is already ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setupRangeInputListeners();
                setupSlider();
                initParamSliders();
                setupToggles();
                initBottomTabs();
                initRPrefix();
                updateCanvasCursor();
            });
        } else {
            setupRangeInputListeners();
            setupSlider();
            initParamSliders();
            setupToggles();
            initBottomTabs();
            initGraphResetButton();
            initRPrefix();
            updateCanvasCursor();
            updateEquationOverlay();
        }
    </script>
    <script src="function-helper.js"></script>
</body>
</html>

